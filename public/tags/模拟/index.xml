<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>模拟 on 奇迹之流WonderfloW</title>
    <link>https://wonderflow.info/tags/%E6%A8%A1%E6%8B%9F/</link>
    <description>Recent content in 模拟 on 奇迹之流WonderfloW</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 22 Jul 2012 11:05:54 +0000</lastBuildDate><atom:link href="https://wonderflow.info/tags/%E6%A8%A1%E6%8B%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ZOJ1030 Farmland &amp;&amp; ZOJ1145 Dreisam Equations</title>
      <link>https://wonderflow.info/posts/2012/07/22/zoj1030-farmland-zoj1145-dreisam-equations/</link>
      <pubDate>Sun, 22 Jul 2012 11:05:54 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/22/zoj1030-farmland-zoj1145-dreisam-equations/</guid>
      <description>zoj1030 《Farmland》绝对是恶心人的题，题目是要求找出边长为n的多边形。但是如果途中有其他的边或者点，就不算。 做法就是枚举每一条边，然后dfs，每次选择夹角最小的点。选择完以后要对所有的点枚举，查看点是否在多边形内。最后，因为每条边都按照正向走和反向走，可能出现重复，怎么解决重复呢，算面积，面积为负的舍弃。 代码写的比较烦躁：WA了十多次，搞了好久，果然我这样的人还是不适合做计算几何的、 #include&amp;lt;iostream&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;map&amp;gt; #define infinity 1e10 #define EP 1e-8 using namespace std; /* * 1.dfs出一个多边形(坐标变换，把一条边转成x轴正方向) * 2.判断多边形内是否有孤立的点，采用射线法， * (射线与多边形的交点是奇数个的时候，点在多边形内，在此之前要判断是否在线</description>
    </item>
    
    <item>
      <title>ZOJ1391 Horizontally Visible Segments &amp;&amp; ZOJ1413 2D Nim</title>
      <link>https://wonderflow.info/posts/2012/07/14/zoj1391-horizontally-visible-segments-zoj1413-2d-nim/</link>
      <pubDate>Sat, 14 Jul 2012 16:02:48 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/14/zoj1391-horizontally-visible-segments-zoj1413-2d-nim/</guid>
      <description>《Horizontally Visible Segments》是一个线段树的题，给你n条垂直的线，问你三条两两互不挡住但是能用横线连起来的直线对有多少。 做法就是用线段树，首先对于x坐标排序，然后对一长条染色，被覆盖住的线段部分显然不可能再被后面的线段所看见。所以只要记录当前直线被哪些线段（id）覆盖过就可以了。最后对于已经标记好颜色的标号集合，枚举任意两个，然后再枚举其中一个的标号集合里面有没有元素的标号集合包含另外一个没使用的。简单来说，就是暴力查看存不存在三个标号两两可以看见。 做法基本就是这样了。 注意点： 1、在标号颜色的时候，要用set判重。 2、写线段树的时候加个延迟标记，表示连续的、同时也是被延迟更新的</description>
    </item>
    
    <item>
      <title>ZOJ1462 Team Them Up! &amp;&amp; ZOJ1066 Square Ice</title>
      <link>https://wonderflow.info/posts/2012/07/12/zoj1462-team-them-upzoj1066-square-ice/</link>
      <pubDate>Thu, 12 Jul 2012 11:56:25 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/12/zoj1462-team-them-upzoj1066-square-ice/</guid>
      <description>今天似乎是被《team them up》虐了一天啊。昨天就知道了解法，就是一直wa。中间还去把当年正常比赛官方数据下载下来对比了一下。结果发现zoj和poj的数据竟然是加强了的。。。。 说下题意：一堆人要分班级，人与人之间有的互相认识，有的不认识。现在只有两个班，但是我分班级有限制条件。 1、一个班级的同学都要互相认识。 2、一个班级里一定要至少有一个人。 3、两个班级里的人数要尽可能靠近 看到这个题可能会没有什么想法。比如我就是这样。然后根据以前的经验，从小数据开始，如果1个人的话怎么分，2个人的话怎么分等等。后来发现这个不存在一个递推关系，因为人之间还有图的关系。 然后就问了一下薛斌怎么想的，发现他的思路很好。</description>
    </item>
    
    <item>
      <title>ZOJ1448 Pattern Matching Using Regular Expression（大自然题！）</title>
      <link>https://wonderflow.info/posts/2012/07/10/zoj1448-pattern-matching-using-regular-expressionefbc88e5a4a7e887aae784b6e9a298efbc81efbc89/</link>
      <pubDate>Tue, 10 Jul 2012 16:59:50 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/10/zoj1448-pattern-matching-using-regular-expressionefbc88e5a4a7e887aae784b6e9a298efbc81efbc89/</guid>
      <description>狗狗四十题里面的这个题非常有意思，号称“大自然”题。其实就是模拟简单正则匹配的规则，录入模式串和匹配串，把最左最长的匹配子串输出出来。 一开始没有什么思路，后来看了watashi的代码，才发现了做法。话说watashi的那个《狗狗40题搞完纪念》绝对是个神贴啊。上面的代码资源，太可贵了！ 具体做法是： 先扫模式串，把模式串的规则整理出来。把一些规则统一起来，如&amp;quot;.&amp;ldquo;的规则，统一为字符0~256之间的任意字符，就是跟【1-9】这种一样咯。 然后用dp[i]表示从i开始作为匹配的头，最后面能匹配到的位置。 最后不得不说，这题还是相当恶心的，模式串从后往前开始对匹配串进行匹配是为了无后效</description>
    </item>
    
    <item>
      <title>ZOJ1237 Fans and Gems（搜索？模拟？恶心的题。。）</title>
      <link>https://wonderflow.info/posts/2012/07/09/zoj-fans-and-gemsefbc88e6909ce7b4a2efbc9fe6a8a1e68b9fefbc9fe681b6e5bf83e79a84e9a298e38082e38082efbc89/</link>
      <pubDate>Mon, 09 Jul 2012 05:52:34 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/09/zoj-fans-and-gemsefbc88e6909ce7b4a2efbc9fe6a8a1e68b9fefbc9fe681b6e5bf83e79a84e9a298e38082e38082efbc89/</guid>
      <description>此题的类型应该就是一个暴力搜索，但是搜索的变换过程非常之恶心。一旦处理不好，就是多写上百行代码的事情。 自己写了五个小时，写不下去了，因为实在恶心到了，处理的方法不好。最后一看watashi的代码，羞愧的五体投地，就把自己的代码人道毁灭了！ 那就学学watashi大牛的代码吧。也挺好。说明一下，代码都是watashi的，我自己只是做了一些适当的注释。其中用的什么样的方法，基本注释里面已经写的很清楚。看来暴力的题目，熟练使用STL才是王道啊。 再结合昨天看watashi代码的经验就是： 该暴力的题，全部使用STL，让代码清楚简洁干净利落到极致！ 该高效的题，尽量使用位运算，不让任何多余的操作降低自己程序的</description>
    </item>
    
  </channel>
</rss>
