<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算几何 on 奇迹之流WonderfloW</title>
    <link>https://wonderflow.info/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</link>
    <description>Recent content in 计算几何 on 奇迹之流WonderfloW</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 22 Jul 2012 11:05:54 +0000</lastBuildDate><atom:link href="https://wonderflow.info/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ZOJ1030 Farmland &amp;&amp; ZOJ1145 Dreisam Equations</title>
      <link>https://wonderflow.info/posts/2012/07/22/zoj1030-farmland-zoj1145-dreisam-equations/</link>
      <pubDate>Sun, 22 Jul 2012 11:05:54 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/22/zoj1030-farmland-zoj1145-dreisam-equations/</guid>
      <description>zoj1030 《Farmland》绝对是恶心人的题，题目是要求找出边长为n的多边形。但是如果途中有其他的边或者点，就不算。 做法就是枚举每一条边，然后dfs，每次选择夹角最小的点。选择完以后要对所有的点枚举，查看点是否在多边形内。最后，因为每条边都按照正向走和反向走，可能出现重复，怎么解决重复呢，算面积，面积为负的舍弃。 代码写的比较烦躁：WA了十多次，搞了好久，果然我这样的人还是不适合做计算几何的、 #include&amp;lt;iostream&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;map&amp;gt; #define infinity 1e10 #define EP 1e-8 using namespace std; /* * 1.dfs出一个多边形(坐标变换，把一条边转成x轴正方向) * 2.判断多边形内是否有孤立的点，采用射线法， * (射线与多边形的交点是奇数个的时候，点在多边形内，在此之前要判断是否在线</description>
    </item>
    
    <item>
      <title>&#39;ZOJ1299 Pendulum &amp;&amp; ZOJ1041 &amp;&amp; ZOJ1060 &amp;&amp; ZOJ1197 &#39;</title>
      <link>https://wonderflow.info/posts/2012/07/18/zoj1299-pendulum-zoj1041-zoj1060-zoj1197/</link>
      <pubDate>Wed, 18 Jul 2012 03:15:04 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/18/zoj1299-pendulum-zoj1041-zoj1060-zoj1197/</guid>
      <description>zoj1299《Pendulum》是个恶心的模拟题，也可以说是个计算几何题，就是模拟一根绳子摆动的过程，中间可能会碰到障碍物导致圆心改变等等。自己写不好，只好学学大神的代码。 #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdio&amp;gt; const double EPS = 1e-4; const int MAXN = 512; //小于 inline bool lt(double a, double b) { return a &amp;lt; b - EPS; } //大于 inline bool gt(double a, double b) { return a &amp;gt; b + EPS; } //等于 inline bool eq(double a, double b) { return fabs(a - b) &amp;lt; EPS; } int main() { int ri = 0, n, p, q; bool flag; double t, r, dr, tr, alpha, beta, gamma; //alpha:当前悬线所在弧度 //beta:当前对比过程中选出的顺时针距当前悬线最近的 //gamma:当前对比过程中第i个的弧度 double x[MAXN], y[MAXN];//所有点都存进来 while (scanf(&amp;quot;%d%lf&amp;quot;, &amp;amp;n, &amp;amp;r) != EOF &amp;amp;&amp;amp; r &amp;gt; 0) { x[0] = y[0] = 0; p = 0; alpha = -M_PI; //M_PI = acos(-1.0) 区别是这个M_PI是头文件里定义</description>
    </item>
    
    <item>
      <title>&#39;ZOJ1460 The Partition of a Cake &#39;</title>
      <link>https://wonderflow.info/posts/2012/07/07/zoj1460-the-partition-of-a-cake/</link>
      <pubDate>Sat, 07 Jul 2012 04:19:58 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/07/zoj1460-the-partition-of-a-cake/</guid>
      <description>这真是过的艰辛的一题啊。搞ACM搞到了最后一年，就决定碰到的每道题都不能错过，尤其是好题目。以前总是想着，放着吧，以后研究到的时候总归会做到的。熟不知以后也会遇到新的题目，一直这样推给以后，其实只是欺骗自己而已。所以，哪怕明知其难，也要迎难而上。 果然不出所料，对于我这个计算几何小白，果然搞了很久才搞定。一开始是想着自己找规律的，但是自己找到的规律也没有自己证明，其实就是YY的，果然不出所料，WA了。然后问HJWAJ怎么做，才知道了方法。就是对于一个空间，每切一刀增加的空间数，就等于点数加一。 关于这一个规律的证明，其实想象一下就可以了。如果没有交点，那么显然是一刀把原来切的哪个平面分成两个。如果</description>
    </item>
    
  </channel>
</rss>
