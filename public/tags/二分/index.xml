<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>二分 on 奇迹之流WonderfloW</title>
    <link>https://wonderflow.info/tags/%E4%BA%8C%E5%88%86/</link>
    <description>Recent content in 二分 on 奇迹之流WonderfloW</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 13 Jul 2012 09:16:05 +0000</lastBuildDate><atom:link href="https://wonderflow.info/tags/%E4%BA%8C%E5%88%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>&#39;ZOJ1389 Fill the Cisterns! &amp;&amp; ZOJ1425 Crossed Matchings &#39;</title>
      <link>https://wonderflow.info/posts/2012/07/13/zoj1389-fill-the-cisterns-zoj1425-crossed-matchings/</link>
      <pubDate>Fri, 13 Jul 2012 09:16:05 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/13/zoj1389-fill-the-cisterns-zoj1425-crossed-matchings/</guid>
      <description>“Fill the Cisterns!”这个题就是给你很多个相连通的水箱，高度体积各不相同，然后给你一定体积的水，问你最后达到的水箱高度是多少。 做法很简单，就是二分。每次枚举每个水箱，算出可以达到的容量跟标准容量比较，然后调整二分的值。注意精度即可。这个算是《狗狗四十题》里面相对简单的题了。 #include&amp;lt;iostream&amp;gt; #include&amp;lt;cstdio&amp;gt; using namespace std; #define EPS 1e-6 struct Node { int b,h,w,d; }node[50100]; int water; int n; bool calc(double m) { double sum = 0; for(int i=0;i&amp;lt;n;i++) { if(node[i].b&amp;lt;m) { if(m&amp;gt;node[i].b+node[i].h) sum+=node[i].h*node[i].w*node[i].d; else sum+=node[i].w*node[i].d*(m-node[i].b); } } if(sum&amp;gt;=water)return true; return false; } int main() { int T; scanf(&amp;quot;%d&amp;quot;,&amp;amp;T); while(T--) { scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); double total=0; for(int i=0;i&amp;lt;n;i++) { scanf(&amp;quot;%d%d%d%d&amp;quot;,&amp;amp;node[i].b,&amp;amp;node[i].h ,&amp;amp;node[i].w,&amp;amp;node[i].d); total+=node[i].h*node[i].w*node[i].d; } scanf(&amp;quot;%d&amp;quot;,&amp;amp;water); double l=0,r=10e9; double mid; if(water&amp;gt;total) { printf(&amp;quot;OVERFLOW\n&amp;quot;); continue; } while(l&amp;lt;r) { mid = (l+r)/2; if(calc(mid))r = mid-0.001; else l = mid+0.001; } printf(&amp;quot;%.2lf\n&amp;quot;,l); } return 0; } “Crossed Matchings”是个有意思的题目，给你上下各一列数，让你进行匹配。规则是数字相同的才可以匹配，且每个数字只可以被匹配一次</description>
    </item>
    
  </channel>
</rss>
