<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>usaco on 奇迹之流WonderfloW</title>
    <link>https://wonderflow.info/tags/usaco/</link>
    <description>Recent content in usaco on 奇迹之流WonderfloW</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 02 Aug 2012 05:37:32 +0000</lastBuildDate><atom:link href="https://wonderflow.info/tags/usaco/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>USACO Raucous Rockers &amp;&amp; Beef McNuggets &amp;&amp; Fence Rails</title>
      <link>https://wonderflow.info/posts/2012/08/02/usaco-raucous-rockers-beef-mcnuggets-fence-rails/</link>
      <pubDate>Thu, 02 Aug 2012 05:37:32 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/08/02/usaco-raucous-rockers-beef-mcnuggets-fence-rails/</guid>
      <description>Raucous Rockers 题目大意：有N(&amp;lt;=20)首歌，打算放在M(&amp;lt;=20)张CD中，每张CD可存储T(&amp;lt;=20)分钟的音乐，给定每首歌的时长，问如何将歌曲按照日期（也就是输入）的顺序，存在这M张CD中，并且每首歌不可以分开存在多张CD上，使得存储的歌曲的数目最多。 解决思路：就是个01背包的变形吧？用滚动数组迭代。dp[m][t],表示我前m张cd用到第t分钟的时候，最多能放多少首歌。N首歌的那一个纬度可以省去，因为每次都只要用到当前纬度的状态。 与01背包的区别就是每次做完一个物品，我都要把影响扩展到后面的每一个容量，也就是说，我前面那些CD就能放下这么多歌了，那么我后面的CD也至少能放那么多</description>
    </item>
    
    <item>
      <title>USACO American Heritage 树的遍历</title>
      <link>https://wonderflow.info/posts/2012/07/06/usaco-american-heritage-e6a091e79a84e9818de58e86/</link>
      <pubDate>Fri, 06 Jul 2012 04:19:18 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/06/usaco-american-heritage-e6a091e79a84e9818de58e86/</guid>
      <description>题目给出树的前序和中序遍历，让你给出树的后续遍历。 我记得正好是两年前，第一次新生赛的时候，就做到了这个题目，那个时候觉得好难啊，也是，连递归都没有理解的人，来做这样的题，确实有点难了。 如输入： ABEDFCHG CBADEFGH 输出： AEFDBHGC 做这题的窍门就是找规律了啊，可以看见，前序遍历的最开始，都是各个子树的根节点。而中序遍历则是可以用来帮助确定子树的范围。 理解了树的结构和递归以后，就很容易了。 此时做起来倒是格外的亲切了。然后写了两个，一个用动态指针存树，一个用静态数组存树。 //动态存树 /* TASK:heritage LANG:C++ USER:BOBO */ #include&amp;lt;iostream&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;cstring&amp;gt; using namespace std; char str1[200],str2[200]; struct Node { char c; Node *l,*r; }*tree; int num; void build(Node * root,int l,int r) { int k = -1; for(int i=l;i&amp;lt;=r;i++) { if(str1[i] == root-&amp;gt;c) { k = i;break; } } if(k-l&amp;gt;0) { root-&amp;gt;l = new Node(); root-&amp;gt;l-&amp;gt;c = str2[num++]; build(root-&amp;gt;l,l,k-1); } else root-&amp;gt;l = NULL; if(r-k&amp;gt;0) { root-&amp;gt;r = new Node(); root-&amp;gt;r-&amp;gt;c = str2[num++]; build(root-&amp;gt;r,k+1,r); }</description>
    </item>
    
    <item>
      <title>USACO A GAME 和 ZOJ1463 Brackets Sequence</title>
      <link>https://wonderflow.info/posts/2012/07/05/usaco-a-game-e5928c-zoj-brackets-sequence/</link>
      <pubDate>Thu, 05 Jul 2012 15:49:27 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/05/usaco-a-game-e5928c-zoj-brackets-sequence/</guid>
      <description>今天正好做了两道DP题，所以一起贴了出来，本身这两道题的关联度不大。 USACO上这题是个博弈，两个人，轮流取数，规则是只能取一个队列两端的数，然后先手和后手都要使用最优策略，使得最后得到的数之和最大。 问先手和后手最后各得多少分。 一开始怎么也想不出来。后来跟方易凡讨论了一下，发现了他常用的一种思考问题的方式。就是先考虑小的情况。 如果队列中只有一个数字的话，显然，先取的人拿走，后手为0. 有两个数字的话，先手拿较大的那个，后手拿较小的那个。 此时，规模扩大到三个。这下怎么办呢？ 其实按照正常的思维方式，就是左右都试试，那么，我取了队列左边的数，队列第二个开始，一直到最右边的数留到了第二轮，在第二轮中，原</description>
    </item>
    
    <item>
      <title>USACO Riding the Fences</title>
      <link>https://wonderflow.info/posts/2012/07/03/usaco-riding-the-fences/</link>
      <pubDate>Tue, 03 Jul 2012 14:33:25 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/03/usaco-riding-the-fences/</guid>
      <description>本身这个就是一个无向图欧拉回路的题。 欧拉回路的两个特性一是连通，二是点的度数要么都为偶数，要么有且仅有两个奇数 然后写的时候，有个递归，递归的退出的时候才存结果，而不是递归一开始的时候存。 为什么呢？ 可能存在这样的情况 1-&amp;gt;2-&amp;gt;3-&amp;gt;4 然后存在3-&amp;gt;5-&amp;gt;6-&amp;gt;3这样一个分支。 先输出的话，按照字典续小的，4就直接被输出了，显然这样就不行了。但是递归的最后才记录的话，说明已经确定了，那就是稳定的情况了。 /* TASK: fence LANG: C++ NAME: BOBO */ #include&amp;lt;iostream&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;memory.h&amp;gt; using namespace std; int f,cnt; bool vis[1500]; int edge[600][600]; int deg[600]; int ans[600]; int ns; void dfs(int index) { for(int i=1;i&amp;lt;=cnt;i++) { if(edge[index][i]) { edge[index][i] = --edge[i][index]; dfs(i); } } ans[ns++] = index; } int main() { int a,b; //freopen(&amp;quot;fence.in&amp;quot;,&amp;quot;r&amp;quot;,stdin); //freopen(&amp;quot;fence.out&amp;quot;,&amp;quot;w&amp;quot;,stdout); while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;f)!=EOF) { ns = cnt = 0; memset(edge,0,sizeof(edge)); memset(deg,0,sizeof(deg)); for(int i=0;i&amp;lt;f;i++) { scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b); edge[a][b] = ++edge[b][a]; cnt = max(a,cnt); cnt = max(b,cnt); deg[a]++; deg[b]++; } int num; for(num=1;num&amp;lt;=cnt;num++)if(deg[num]%2)break; if(num==cnt+1)dfs(1); else dfs(num); for(int i=ns-1;i&amp;gt;=0;i--) { printf(&amp;quot;%d\n&amp;quot;,ans[i]); } } }</description>
    </item>
    
  </channel>
</rss>
