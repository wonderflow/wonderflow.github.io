<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>拓扑排序 on 奇迹之流WonderfloW</title>
    <link>https://wonderflow.info/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
    <description>Recent content in 拓扑排序 on 奇迹之流WonderfloW</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 18 Jul 2012 03:15:04 +0000</lastBuildDate><atom:link href="https://wonderflow.info/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>&#39;ZOJ1299 Pendulum &amp;&amp; ZOJ1041 &amp;&amp; ZOJ1060 &amp;&amp; ZOJ1197 &#39;</title>
      <link>https://wonderflow.info/posts/2012/07/18/zoj1299-pendulum-zoj1041-zoj1060-zoj1197/</link>
      <pubDate>Wed, 18 Jul 2012 03:15:04 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/18/zoj1299-pendulum-zoj1041-zoj1060-zoj1197/</guid>
      <description>zoj1299《Pendulum》是个恶心的模拟题，也可以说是个计算几何题，就是模拟一根绳子摆动的过程，中间可能会碰到障碍物导致圆心改变等等。自己写不好，只好学学大神的代码。 #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdio&amp;gt; const double EPS = 1e-4; const int MAXN = 512; //小于 inline bool lt(double a, double b) { return a &amp;lt; b - EPS; } //大于 inline bool gt(double a, double b) { return a &amp;gt; b + EPS; } //等于 inline bool eq(double a, double b) { return fabs(a - b) &amp;lt; EPS; } int main() { int ri = 0, n, p, q; bool flag; double t, r, dr, tr, alpha, beta, gamma; //alpha:当前悬线所在弧度 //beta:当前对比过程中选出的顺时针距当前悬线最近的 //gamma:当前对比过程中第i个的弧度 double x[MAXN], y[MAXN];//所有点都存进来 while (scanf(&amp;quot;%d%lf&amp;quot;, &amp;amp;n, &amp;amp;r) != EOF &amp;amp;&amp;amp; r &amp;gt; 0) { x[0] = y[0] = 0; p = 0; alpha = -M_PI; //M_PI = acos(-1.0) 区别是这个M_PI是头文件里定义</description>
    </item>
    
    <item>
      <title>ZOJ1509 Family(高精度，DP，拓扑排序)</title>
      <link>https://wonderflow.info/posts/2012/07/09/160/</link>
      <pubDate>Mon, 09 Jul 2012 15:35:33 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/09/160/</guid>
      <description>这题确实是个好题目。讲的是动物家族，每个人都有50%父亲的基因和50%母亲的基因，然后给你一张家族图，最后询问你指定的两个人中有相同的血缘关系的百分比是多少。 一开始其实是没什么想法的。就问了问老高，后来才知道，原来是个DP。 为了无后效性，所以我们必须要先进行拓扑排序，这样的话，先把祖先之间的血缘关系求出来，然后子孙后代的寻缘关系其实可以递推到子孙的其中一人与另外一人上一辈的血缘关系的。 首先dp[i][j]表示，第i个人和第j个人的基因相同的比例是多少。 然后dp[i][i]肯定是初始化为1的。 另外，从拓扑排序后的先祖开始计算DP值，那么两重for循环，i在j前面。也就是j肯定比i的备份小，那么要</description>
    </item>
    
  </channel>
</rss>
