<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>暴力 on 奇迹之流WonderfloW</title>
    <link>https://wonderflow.info/tags/%E6%9A%B4%E5%8A%9B/</link>
    <description>Recent content in 暴力 on 奇迹之流WonderfloW</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 14 Jul 2012 16:02:48 +0000</lastBuildDate><atom:link href="https://wonderflow.info/tags/%E6%9A%B4%E5%8A%9B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ZOJ1391 Horizontally Visible Segments &amp;&amp; ZOJ1413 2D Nim</title>
      <link>https://wonderflow.info/posts/2012/07/14/zoj1391-horizontally-visible-segments-zoj1413-2d-nim/</link>
      <pubDate>Sat, 14 Jul 2012 16:02:48 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/14/zoj1391-horizontally-visible-segments-zoj1413-2d-nim/</guid>
      <description>《Horizontally Visible Segments》是一个线段树的题，给你n条垂直的线，问你三条两两互不挡住但是能用横线连起来的直线对有多少。 做法就是用线段树，首先对于x坐标排序，然后对一长条染色，被覆盖住的线段部分显然不可能再被后面的线段所看见。所以只要记录当前直线被哪些线段（id）覆盖过就可以了。最后对于已经标记好颜色的标号集合，枚举任意两个，然后再枚举其中一个的标号集合里面有没有元素的标号集合包含另外一个没使用的。简单来说，就是暴力查看存不存在三个标号两两可以看见。 做法基本就是这样了。 注意点： 1、在标号颜色的时候，要用set判重。 2、写线段树的时候加个延迟标记，表示连续的、同时也是被延迟更新的</description>
    </item>
    
    <item>
      <title>ZOJ1426 Counting Rectangles &amp;&amp; ZOJ1387 Decoding Morse Sequences</title>
      <link>https://wonderflow.info/posts/2012/07/13/zoj1426-counting-rectangles-zoj1387-decoding-morse-sequences/</link>
      <pubDate>Fri, 13 Jul 2012 08:31:13 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/13/zoj1426-counting-rectangles-zoj1387-decoding-morse-sequences/</guid>
      <description>Counting Rectangles 这题一开始都没人做，其实就是个水题。因为题目中说的很清楚，只会有垂直和水平的线。这个时候，我们可以枚举任意两条横线，对于每条竖线，看有多少竖线跟这两条横线相交，设相交数为tmp。最后对于这两条横线和所有的竖线构成的矩形个数就是(temp-1)*temp/2（一个框构成的矩形有temp-1个，两个框构成的矩形有temp-2个。。以此类推至1个）。这样就能在N^3的复杂度内算出所有矩形个数了。 /* 枚举任意两条横线，对于每条竖线，看有多少竖线跟这两条横线相交，设相交数为tmp 最后对于这两条横线和所有的竖线构成的矩形个数就是(temp-1)*temp/2 这样就能在N^3的复杂度内算出所有矩形个数了。</description>
    </item>
    
    <item>
      <title>ZOJ1237 Fans and Gems（搜索？模拟？恶心的题。。）</title>
      <link>https://wonderflow.info/posts/2012/07/09/zoj-fans-and-gemsefbc88e6909ce7b4a2efbc9fe6a8a1e68b9fefbc9fe681b6e5bf83e79a84e9a298e38082e38082efbc89/</link>
      <pubDate>Mon, 09 Jul 2012 05:52:34 +0000</pubDate>
      
      <guid>https://wonderflow.info/posts/2012/07/09/zoj-fans-and-gemsefbc88e6909ce7b4a2efbc9fe6a8a1e68b9fefbc9fe681b6e5bf83e79a84e9a298e38082e38082efbc89/</guid>
      <description>此题的类型应该就是一个暴力搜索，但是搜索的变换过程非常之恶心。一旦处理不好，就是多写上百行代码的事情。 自己写了五个小时，写不下去了，因为实在恶心到了，处理的方法不好。最后一看watashi的代码，羞愧的五体投地，就把自己的代码人道毁灭了！ 那就学学watashi大牛的代码吧。也挺好。说明一下，代码都是watashi的，我自己只是做了一些适当的注释。其中用的什么样的方法，基本注释里面已经写的很清楚。看来暴力的题目，熟练使用STL才是王道啊。 再结合昨天看watashi代码的经验就是： 该暴力的题，全部使用STL，让代码清楚简洁干净利落到极致！ 该高效的题，尽量使用位运算，不让任何多余的操作降低自己程序的</description>
    </item>
    
  </channel>
</rss>
