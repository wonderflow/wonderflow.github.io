<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on 奇迹之流WonderfloW</title>
    <link>https://wonderflow.info/categories/javascript/</link>
    <description>Recent content in JavaScript on 奇迹之流WonderfloW</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 15 Sep 2013 16:31:10 +0000</lastBuildDate>
    <atom:link href="https://wonderflow.info/categories/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JavaScript中的闭包（JavaScript权威指南读书笔记）</title>
      <link>https://wonderflow.info/posts/2013/09/15/javascripte4b8ade79a84e997ade58c85efbc88javascripte69d83e5a881e68c87e58d97e8afbbe4b9a6e7ac94e8aeb0efbc89/</link>
      <pubDate>Sun, 15 Sep 2013 16:31:10 +0000</pubDate>
      <guid>https://wonderflow.info/posts/2013/09/15/javascripte4b8ade79a84e997ade58c85efbc88javascripte69d83e5a881e68c87e58d97e8afbbe4b9a6e7ac94e8aeb0efbc89/</guid>
      <description>&lt;p&gt;最近在看javascript的书，稍微学习一些前端的东西，以便做些web应用的方便。&lt;/p&gt;&#xA;&lt;p&gt;以前看到闭包这个概念一直不太懂，今天下定决心好好研读了一下，终于明白了一二。&lt;/p&gt;&#xA;&lt;p&gt;像绝大多数高级编程语言，javascript也有其词法的作用域。意思是说，当函数被执行的时候，起作用的不是被调用时的变量作用域，而是在函数被定义的时候声明的变量域。所以为了实现这个词法作用域的功能，javascript必须在中间过程中不仅保存函数的代码，还需要保存当时所引用的作用域链。&lt;a href=&#34;http://en.wikipedia.org/wiki/Closure_(computer_science)&#34;&gt;这个函数对象和函数变量保存起来的作用域的组合在计算机科学里的称呼就叫做闭包。&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;从技术角度来说，javascript里的函数都是闭包：它们都是对象，并且它们有一个与之关联的作用域链。大多数函数被调用的时候，影响它们的作用域与定义它们的作用域是相同的，但是这并不影响它们是闭包。只有当函数被调用的时候，影响它们的作用域与定义它们时候的不相同的时候，闭包的概念才会变得有趣起来。&lt;strong&gt;这个通常发生在函数的返回值本身就是一个内嵌函数的时候。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;要理解闭包的概念，我们先来看一段内嵌函数返回相关的代码。&lt;/p&gt;&#xA;&lt;p&gt;{% codeblock %}&lt;/p&gt;&#xA;&lt;p&gt;var scope = &amp;ldquo;global scope&amp;rdquo;; // A global variable&#xA;function checkscope() {&#xA;var scope = &amp;ldquo;local scope&amp;rdquo;; // A local variable&#xA;function f() { return scope; } // Return the value in scope here&#xA;return f();&#xA;}&#xA;checkscope() // =&amp;gt; &amp;ldquo;local scope&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;{% endcodeblock %}&lt;/p&gt;&#xA;&lt;p&gt;checkscope()函数在内部定义了函数f，并在返回的时候执行了f函数，所以我们得到了结果 “local scope”。&lt;/p&gt;&#xA;&lt;p&gt;再来看看下面这段：&lt;/p&gt;&#xA;&lt;p&gt;{% codeblock %}&lt;/p&gt;&#xA;&lt;p&gt;var scope = &amp;ldquo;global scope&amp;rdquo;; // A global variable&#xA;function checkscope() {&#xA;var scope = &amp;ldquo;local scope&amp;rdquo;; // A local variable&#xA;function f() { return scope; } // Return the value in scope here&#xA;return f;&#xA;}&#xA;checkscope()() // What does this return?&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
