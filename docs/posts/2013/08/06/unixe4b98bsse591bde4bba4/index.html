<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>UNIX之ss命令 | 奇迹之流WonderfloW</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="ss命令用来进行统计socket连接的统计。与netstat命令相似。 这个命令之前不常用，甚至没怎么听过，直到有一天不小心想要输入ssh的时候打了ss就回车，结果出来意想不到的好东西，让我决定去学习一下。
SS能提供的信息包括：


TCP连接


UDP连接


已经建立的 ssh/ftp/http/https连接


本地进程连向X服务器的连接


筛选状态(例如connected, synchronized, SYN-RECV, SYN-SENT,TIME-WAIT)、地址和端口


所有在FIN-WAIT-1状态下的TCP连接。


大多数linux发行版都涵盖ss命令以及其他一些工具，熟悉这些命令有助于多网络状态的掌握。
下面罗列出一些常用的方法。
{% codeblock %}
$ ss -s #列出所有的socket连接（-s summary）
$ ss -l #列出所有打开的网络端口
$ ss -l | grep 80 #与grep命令一起用把80端口的socket连接信息查出来
$ ss -p #列出使用了socket的进程
$ ss -t -a #列出所有TCP连接
$ ss -u -a #列出所有udp连接
$ ss -o state established &lsquo;(dport = :smtp or sport = :smtp )&rsquo; #列出所有已建立的SMTP连接
$ ss -o state established &lsquo;(dport = :http or sport = :http )&rsquo; #列出所有已建立的http连接
$ ss -x src /tmp/.X11-unix/* #列出所有本地进程连向Xserver的连接
$ ss -o state fin-wait-1 &lsquo;( sport = :http or sport = :https )&rsquo; dst 192.168.1/24 #列出所有在fin-wait-1状态的TCP连接，查看他们的计时器
#关于fin-wait-1，是发出了连接，还没有得到对方的握手信号的状态，
#这时连接不接收应用的发送请求，只接收服务器的反馈信号，
#直到计时器超时">
    <meta name="generator" content="Hugo 0.153.4">
    
    
    
      <meta name="robots" content="index, follow">
    
    <meta name="author" content="admin">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.efe4d852f731d5d1fbb87718387202a97aafd768cdcdaed0662bbe6982e91824.css" >



  
    <link rel="stylesheet" href="/css/custom.css">
  


    


    
      
<link rel="shortcut icon" href="/favicon_io/favicon.ico" type="image/x-icon" />


    

    

    
      <link rel="canonical" href="https://wonderflow.info/posts/2013/08/06/unixe4b98bsse591bde4bba4/">
    

    
    
    <meta property="og:url" content="https://wonderflow.info/posts/2013/08/06/unixe4b98bsse591bde4bba4/">
  <meta property="og:site_name" content="奇迹之流WonderfloW">
  <meta property="og:title" content="UNIX之ss命令">
  <meta property="og:description" content="ss命令用来进行统计socket连接的统计。与netstat命令相似。 这个命令之前不常用，甚至没怎么听过，直到有一天不小心想要输入ssh的时候打了ss就回车，结果出来意想不到的好东西，让我决定去学习一下。
SS能提供的信息包括：
TCP连接
UDP连接
已经建立的 ssh/ftp/http/https连接
本地进程连向X服务器的连接
筛选状态(例如connected, synchronized, SYN-RECV, SYN-SENT,TIME-WAIT)、地址和端口
所有在FIN-WAIT-1状态下的TCP连接。
大多数linux发行版都涵盖ss命令以及其他一些工具，熟悉这些命令有助于多网络状态的掌握。
下面罗列出一些常用的方法。
{% codeblock %}
$ ss -s #列出所有的socket连接（-s summary） $ ss -l #列出所有打开的网络端口 $ ss -l | grep 80 #与grep命令一起用把80端口的socket连接信息查出来 $ ss -p #列出使用了socket的进程 $ ss -t -a #列出所有TCP连接 $ ss -u -a #列出所有udp连接 $ ss -o state established ‘(dport = :smtp or sport = :smtp )’ #列出所有已建立的SMTP连接 $ ss -o state established ‘(dport = :http or sport = :http )’ #列出所有已建立的http连接 $ ss -x src /tmp/.X11-unix/* #列出所有本地进程连向Xserver的连接 $ ss -o state fin-wait-1 ‘( sport = :http or sport = :https )’ dst 192.168.1/24 #列出所有在fin-wait-1状态的TCP连接，查看他们的计时器 #关于fin-wait-1，是发出了连接，还没有得到对方的握手信号的状态， #这时连接不接收应用的发送请求，只接收服务器的反馈信号， #直到计时器超时">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2013-08-06T02:31:59+00:00">
    <meta property="article:modified_time" content="2013-08-06T02:31:59+00:00">
    <meta property="article:tag" content="Linux">
    <meta property="article:tag" content="Ss">
    <meta property="article:tag" content="Unix">

  <meta itemprop="name" content="UNIX之ss命令">
  <meta itemprop="description" content="ss命令用来进行统计socket连接的统计。与netstat命令相似。 这个命令之前不常用，甚至没怎么听过，直到有一天不小心想要输入ssh的时候打了ss就回车，结果出来意想不到的好东西，让我决定去学习一下。
SS能提供的信息包括：
TCP连接
UDP连接
已经建立的 ssh/ftp/http/https连接
本地进程连向X服务器的连接
筛选状态(例如connected, synchronized, SYN-RECV, SYN-SENT,TIME-WAIT)、地址和端口
所有在FIN-WAIT-1状态下的TCP连接。
大多数linux发行版都涵盖ss命令以及其他一些工具，熟悉这些命令有助于多网络状态的掌握。
下面罗列出一些常用的方法。
{% codeblock %}
$ ss -s #列出所有的socket连接（-s summary） $ ss -l #列出所有打开的网络端口 $ ss -l | grep 80 #与grep命令一起用把80端口的socket连接信息查出来 $ ss -p #列出使用了socket的进程 $ ss -t -a #列出所有TCP连接 $ ss -u -a #列出所有udp连接 $ ss -o state established ‘(dport = :smtp or sport = :smtp )’ #列出所有已建立的SMTP连接 $ ss -o state established ‘(dport = :http or sport = :http )’ #列出所有已建立的http连接 $ ss -x src /tmp/.X11-unix/* #列出所有本地进程连向Xserver的连接 $ ss -o state fin-wait-1 ‘( sport = :http or sport = :https )’ dst 192.168.1/24 #列出所有在fin-wait-1状态的TCP连接，查看他们的计时器 #关于fin-wait-1，是发出了连接，还没有得到对方的握手信号的状态， #这时连接不接收应用的发送请求，只接收服务器的反馈信号， #直到计时器超时">
  <meta itemprop="datePublished" content="2013-08-06T02:31:59+00:00">
  <meta itemprop="dateModified" content="2013-08-06T02:31:59+00:00">
  <meta itemprop="wordCount" content="404">
  <meta itemprop="keywords" content="Linux,Ss,Unix">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="UNIX之ss命令">
  <meta name="twitter:description" content="ss命令用来进行统计socket连接的统计。与netstat命令相似。 这个命令之前不常用，甚至没怎么听过，直到有一天不小心想要输入ssh的时候打了ss就回车，结果出来意想不到的好东西，让我决定去学习一下。
SS能提供的信息包括：
TCP连接
UDP连接
已经建立的 ssh/ftp/http/https连接
本地进程连向X服务器的连接
筛选状态(例如connected, synchronized, SYN-RECV, SYN-SENT,TIME-WAIT)、地址和端口
所有在FIN-WAIT-1状态下的TCP连接。
大多数linux发行版都涵盖ss命令以及其他一些工具，熟悉这些命令有助于多网络状态的掌握。
下面罗列出一些常用的方法。
{% codeblock %}
$ ss -s #列出所有的socket连接（-s summary） $ ss -l #列出所有打开的网络端口 $ ss -l | grep 80 #与grep命令一起用把80端口的socket连接信息查出来 $ ss -p #列出使用了socket的进程 $ ss -t -a #列出所有TCP连接 $ ss -u -a #列出所有udp连接 $ ss -o state established ‘(dport = :smtp or sport = :smtp )’ #列出所有已建立的SMTP连接 $ ss -o state established ‘(dport = :http or sport = :http )’ #列出所有已建立的http连接 $ ss -x src /tmp/.X11-unix/* #列出所有本地进程连向Xserver的连接 $ ss -o state fin-wait-1 ‘( sport = :http or sport = :https )’ dst 192.168.1/24 #列出所有在fin-wait-1状态的TCP连接，查看他们的计时器 #关于fin-wait-1，是发出了连接，还没有得到对方的握手信号的状态， #这时连接不接收应用的发送请求，只接收服务器的反馈信号， #直到计时器超时">

      
      
    
	
  </head><body class="ma0 avenir production">

    

  <header>
    <div class="bg-near-white">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        奇迹之流WonderfloW
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/about/" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/archives/" title="Archives page">
              Archives
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>
    </div>
  </header>


    <main class="pb7" role="main">
      
<div class="flex-l mt2 mw8 center">
  <article class="center cf pv5 ph3 ph4-ns mw7">
    <header>
      <p class="f6 b helvetica tracked">
        POSTS
      </p>
      <h1 class="f1">
        UNIX之ss命令
      </h1>
    </header>
    <div class="nested-copy-line-height lh-copy f4 nested-links nested-img mid-gray">
      <p>ss命令用来进行统计socket连接的统计。与netstat命令相似。 这个命令之前不常用，甚至没怎么听过，直到有一天不小心想要输入ssh的时候打了ss就回车，结果出来意想不到的好东西，让我决定去学习一下。</p>
<p><strong>SS</strong>能提供的信息包括：</p>
<ol>
<li>
<p>TCP连接</p>
</li>
<li>
<p>UDP连接</p>
</li>
<li>
<p>已经建立的 ssh/ftp/http/https连接</p>
</li>
<li>
<p>本地进程连向X服务器的连接</p>
</li>
<li>
<p>筛选状态(例如connected, synchronized, SYN-RECV, SYN-SENT,TIME-WAIT)、地址和端口</p>
</li>
<li>
<p>所有在FIN-WAIT-1状态下的TCP连接。</p>
</li>
</ol>
<p>大多数linux发行版都涵盖ss命令以及其他一些工具，熟悉这些命令有助于多网络状态的掌握。</p>
<p>下面罗列出一些常用的方法。</p>
<p>{% codeblock %}</p>
<p>$ ss -s #列出所有的socket连接（-s summary）
$ ss -l #列出所有打开的网络端口
$ ss -l | grep 80 #与grep命令一起用把80端口的socket连接信息查出来
$ ss -p #列出使用了socket的进程
$ ss -t -a #列出所有TCP连接
$ ss -u -a #列出所有udp连接
$ ss -o state established &lsquo;(dport = :smtp or sport = :smtp )&rsquo; #列出所有已建立的SMTP连接
$ ss -o state established &lsquo;(dport = :http or sport = :http )&rsquo; #列出所有已建立的http连接
$ ss -x src /tmp/.X11-unix/* #列出所有本地进程连向Xserver的连接
$ ss -o state fin-wait-1 &lsquo;( sport = :http or sport = :https )&rsquo; dst 192.168.1/24 #列出所有在fin-wait-1状态的TCP连接，查看他们的计时器
#关于fin-wait-1，是发出了连接，还没有得到对方的握手信号的状态，
#这时连接不接收应用的发送请求，只接收服务器的反馈信号，
#直到计时器超时</p>
<p>{% endcodeblock %}</p>
<p>关于TCP状态的筛选：</p>
<p>{% codeblock %}</p>
<p>#IPV4
$ ss -4 state [筛选器]
#IPV6
$ ss -6 state [筛选器]</p>
<p>{% endcodeblock %}</p>
<p>筛选器有以下几种</p>
<ul>
<li>
<p>established</p>
</li>
<li>
<p>syn-sent</p>
</li>
<li>
<p>syn-recv</p>
</li>
<li>
<p>fin-wait-1</p>
</li>
<li>
<p>fin-wait-2</p>
</li>
<li>
<p>time-wait</p>
</li>
<li>
<p>closed</p>
</li>
<li>
<p>close-wait</p>
</li>
<li>
<p>last-ack</p>
</li>
<li>
<p>listen</p>
</li>
<li>
<p>closing</p>
</li>
<li>
<p>all : All of the above states</p>
</li>
<li>
<p>connected : All the states except for listen and closed</p>
</li>
<li>
<p>synchronized : All the connected states except for syn-sent</p>
</li>
<li>
<p>bucket : Show states, which are maintained as minisockets, i.e. time-wait and syn-recv.</p>
</li>
<li>
<p>big : Opposite to bucket state. 例如查看已经关闭的IPV4连接的状态：</p>
</li>
</ul>
<p>{% codeblock %}
$ ss -4 state closing
{% endcodeblock %}</p>
<p>根据远程IP地址和端口查看连接信息</p>
<p>{% codeblock %}</p>
<p>$ ss dst 192.168.0.1
$ ss dst 192.168.0.1:http</p>
<p>{% endcodeblock %}</p>
<p>查看本地的地址和端口的连接信息</p>
<p>$ ss src 192.168.0.121
$ ss src 192.168.0.121:http 仅通过端口来查看连接 远端的参数是dport 本地的参数是sport</p>
<p>{% codeblock %}</p>
<p>$ ss dport = :http
$ ss sport = :http
$ ss sport = :80</p>
<p>{% endcodeblock %}</p>
<p>除了等于外还有其他操作符匹配方式：
<strong>&lt;= or le</strong> : Less than or equal to port
<strong>&gt;= or ge</strong> : Greater than or equal to port
<strong>== or eq</strong> : Equal to port
<strong>!= or ne</strong> : Not equal to port
**&lt; or gt **: Less than to port
<strong>&gt; or lt</strong> : Greater than to port
<strong>Note</strong>: le, gt, eq, ne etc. are use in unix shell and are accepted as well.</p>
<p>{% codeblock %}</p>
<p>#注意特殊符号要转义字符
$ ss dport &gt; :1024
$ ss (sport = :http or sport = :https )</p>
<p>{% endcodeblock %}</p>
<p>另外，我之前因为一直使用netstat , 后来发现ss几乎涵盖了netstat的功能，常常困惑着两个有什么不同。</p>
<p>下面是我找到的比较好的答案：</p>
<p>ss command is included in iproute2 package and is the substitute of the command netstat.ss is used to dump socket statistics. It allows showing information similar to netstat. It can display more TCP and state informations than other tools. It is a new, incredibly useful and faster (as compare to netstat) tool for tracking TCP connections and sockets.</p>
<p><strong>Resources from</strong>：<a href="http://www.cyberciti.biz/tips/linux-investigate-sockets-network-connections.html">ss: Display Linux TCP / UDP Network and Socket Information</a></p>

    </div>
  </article>
</div>

    </main>
    <footer class="bg-near-white bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
    <a class="f4 fw4 hover-black no-underline mid-gray dn dib-ns pv2 ph3" href="https://wonderflow.info/">
      &copy;  奇迹之流WonderfloW 2025 
    </a>
    <div><div class="ananke-socials"></div>
</div>
    <a href="https://beian.miit.gov.cn/" class="link db f6 pa2 br3 bg-mid-gray white dim w4 tc"> 沪ICP备2020029591号 </a>
    
  </div>
</footer>


<div class="reading-progress" id="reading-progress"></div>


<button class="back-to-top" id="back-to-top" aria-label="Back to top">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <polyline points="18 15 12 9 6 15"></polyline>
  </svg>
</button>


<script>
(function() {
  
  const progressBar = document.getElementById('reading-progress');
  const backToTop = document.getElementById('back-to-top');

  function updateProgress() {
    const scrollTop = window.scrollY;
    const docHeight = document.documentElement.scrollHeight - window.innerHeight;
    const progress = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;

    if (progressBar) {
      progressBar.style.width = progress + '%';
    }

    
    if (backToTop) {
      if (scrollTop > 300) {
        backToTop.classList.add('visible');
      } else {
        backToTop.classList.remove('visible');
      }
    }
  }

  
  let ticking = false;
  window.addEventListener('scroll', function() {
    if (!ticking) {
      window.requestAnimationFrame(function() {
        updateProgress();
        ticking = false;
      });
      ticking = true;
    }
  });

  
  if (backToTop) {
    backToTop.addEventListener('click', function() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });
  }

  
  updateProgress();
})();
</script>

  </body>
</html>
