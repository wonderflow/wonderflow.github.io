<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Cloud_Controller_NG源码阅读记录 | 奇迹之流WonderfloW</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.75.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.4fc0b62e4b82c997bb0041217cd6b979.css" rel="stylesheet">
    

    

    
      
<link rel="shortcut icon" href="/favicon_io/favicon.ico" type="image/x-icon" />


    

    
    
    <meta property="og:title" content="Cloud_Controller_NG源码阅读记录" />
<meta property="og:description" content="Cloud_Controller_NG源码阅读记录 @(CC阅读)[cloud controller] by wonderflow Cloud_Controller_NG就是cloud controller next generation的意思。即Cloud Foundry 平台用来管理控制应用和服务的组件。 官方文档是这么解释CCNG的作用的： 维护一个包含应用、服务、配置信息的数据库(CCDB)。 在blobstore中存储应用的packages和droplets。 通过NATS和其他组件进行通信，包括Droplet Execution Agents (DEAs)、Service Gateways、和 Health Manager（HM）。 其他供用户调用的后端API。 阅读该组件源码，有助于从应用管理的视角理解cloudfoundry的运行" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wonderflow.info/posts/2014/02/28/cloud_controller_nge6ba90e7a081e99885e8afbbe8aeb0e5bd95/" />
<meta property="article:published_time" content="2014-02-28T04:14:33+00:00" />
<meta property="article:modified_time" content="2014-02-28T04:14:33+00:00" />
<meta itemprop="name" content="Cloud_Controller_NG源码阅读记录">
<meta itemprop="description" content="Cloud_Controller_NG源码阅读记录 @(CC阅读)[cloud controller] by wonderflow Cloud_Controller_NG就是cloud controller next generation的意思。即Cloud Foundry 平台用来管理控制应用和服务的组件。 官方文档是这么解释CCNG的作用的： 维护一个包含应用、服务、配置信息的数据库(CCDB)。 在blobstore中存储应用的packages和droplets。 通过NATS和其他组件进行通信，包括Droplet Execution Agents (DEAs)、Service Gateways、和 Health Manager（HM）。 其他供用户调用的后端API。 阅读该组件源码，有助于从应用管理的视角理解cloudfoundry的运行">
<meta itemprop="datePublished" content="2014-02-28T04:14:33+00:00" />
<meta itemprop="dateModified" content="2014-02-28T04:14:33+00:00" />
<meta itemprop="wordCount" content="12454">



<meta itemprop="keywords" content="ccng,cf," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Cloud_Controller_NG源码阅读记录"/>
<meta name="twitter:description" content="Cloud_Controller_NG源码阅读记录 @(CC阅读)[cloud controller] by wonderflow Cloud_Controller_NG就是cloud controller next generation的意思。即Cloud Foundry 平台用来管理控制应用和服务的组件。 官方文档是这么解释CCNG的作用的： 维护一个包含应用、服务、配置信息的数据库(CCDB)。 在blobstore中存储应用的packages和droplets。 通过NATS和其他组件进行通信，包括Droplet Execution Agents (DEAs)、Service Gateways、和 Health Manager（HM）。 其他供用户调用的后端API。 阅读该组件源码，有助于从应用管理的视角理解cloudfoundry的运行"/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    



  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        奇迹之流WonderfloW
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/archives/" title="Archives page">
              Archives
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/posts/" title="Posts page">
              Posts
            </a>
          </li>
          
        </ul>
      
      








<a href="https://github.com/wonderflow" target="_blank" class="link-transition github link dib z-999 pt3 pt0-l mr1" title="Github link" rel="noopener" aria-label="follow on Github——Opens in a new window">
  <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>








    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      

<article class="flex-l flex-wrap justify-between mw8 center ph3">
  <header class="mt4 w-100">
    <aside class="instapaper_ignoref b helvetica tracked">
      
      POSTS
    </aside>
    




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://wonderflow.info/posts/2014/02/28/cloud_controller_nge6ba90e7a081e99885e8afbbe8aeb0e5bd95/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://wonderflow.info/posts/2014/02/28/cloud_controller_nge6ba90e7a081e99885e8afbbe8aeb0e5bd95/&amp;text=Cloud_Controller_NG%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e8%ae%b0%e5%bd%95" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://wonderflow.info/posts/2014/02/28/cloud_controller_nge6ba90e7a081e99885e8afbbe8aeb0e5bd95/&amp;title=Cloud_Controller_NG%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb%e8%ae%b0%e5%bd%95" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>


    <h1 class="f1 athelas mt3 mb1">Cloud_Controller_NG源码阅读记录</h1>
    
    <p class="tracked">
      By <strong>
        
        admin
        
      </strong>
    </p>
    
    
    <time class="f6 mv4 dib tracked"
      datetime="2014-02-28T04:14:33Z">February 28, 2014</time>

    
    
    <span class="f6 mv4 dib tracked"> - 25 minutes read</span>
    <span class="f6 mv4 dib tracked"> - 12454 words</span>
    
  </header>
  <div
    class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-100-l"><h1 id="cloud_controller_ng源码阅读记录">Cloud_Controller_NG源码阅读记录</h1>
<p>@(CC阅读)[cloud controller] by wonderflow</p>
<hr>
<p>Cloud_Controller_NG就是cloud controller next generation的意思。即Cloud Foundry 平台用来管理控制应用和服务的组件。</p>
<p><a href="http://docs.cloudfoundry.com/docs/using/terms.html#ccng">官方文档</a>是这么解释CCNG的作用的：</p>
<ul>
<li>维护一个包含应用、服务、配置信息的数据库(CCDB)。</li>
<li>在blobstore中存储应用的packages和droplets。</li>
<li>通过NATS和其他组件进行通信，包括Droplet Execution Agents (DEAs)、Service Gateways、和 Health Manager（HM）。</li>
<li>其他供用户调用的后端API。</li>
</ul>
<p>阅读该组件源码，有助于从应用管理的视角理解cloudfoundry的运行过程。</p>
<p><strong>说明：</strong></p>
<ol>
<li>Cloud_Controller_NG以下简称CCNG。</li>
<li>本文所阅读的源码版本为github中cf-release中V145 tag下面的CCNG项目源码。</li>
</ol>
<hr>
<h1 id="ccng各模块概览">CCNG各模块概览</h1>
<p>首先让我们看一下这张框架图：
<img src="https://wonderflow.info/images/2014-02-28-cloud_controller_nge6ba90e7a081e99885e8afbbe8aeb0e5bd95/ccng.png" alt="Alt text">
<strong>图1.CCNG架构图byshlallen</strong></p>
<p>从ccng架构图中可以看出ccng可以分为以下多个模块：</p>
<ol>
<li>Stager模块，主要负责与DEA组件的staging部分进行交互；</li>
<li>DEA模块，主要负责与DEA组件进行交互；</li>
<li>Blobstore模块，主要负责创建一个blobstore的存储，以供Cloud Foundry存储应用所需的静态文件；</li>
<li>HealthManager（HM）模块，主要负责与HealthManager组件进行交互；</li>
<li>CCDB模块，负责维护cloud_controller的数据库；</li>
<li>collector_registrar模块，负责作为component向Collector组件注册；</li>
<li>router_registrar模块，负责将cloud controller组件的域名注册至Router组件；</li>
<li>legacy_api部分，负责接管ccng关于info，bulk以及services等的RESTful请求；</li>
<li>Permission模块，负责各种不同权限用户的注册和认证。</li>
<li>其他零散模块</li>
</ol>
<p>我们按官方文档给出的组件功能介绍的顺序逐步深入各模块。</p>
<!-- raw HTML omitted -->
<h2 id="db模块">DB模块</h2>
<p>众所周知，CCDB就是CC的一个postgresql数据库，用于存储CC需要的一些数据。</p>
<p>在CCNG的rakefile里面，有着CCDB建表的初始化信息，具体的建表内容在<code>db/migrations/*.rb</code>中。</p>
<p>CCNG开始正常运行后，主要调用lib/sequel_plugins/update_or_create.rb里面的函数对以下信息的改变进行更新（更新的代码都在以下各部分的源码中，可以使用全文搜索update_or_create函数查看）。</p>
<ol>
<li>framework：语言运行时框架。就是<code>&quot;*.war&quot;</code>包可上传的各种框架，在<code>/var/vcap/jobs/cloud_controller/config/staging</code>路径下的各类*.yml存储。@<code>lib/cloud_controller/models/framework.rb</code></li>
<li>stack ：应用运行的堆环境，默认为lucid64。<a href="http://docs.cloudfoundry.com/docs/running/architecture/stacks.html">stacks</a>就是一个预先构建的文件系统，包括可运行应用的操作系统环境。@<code>lib/cloud_controller/models/stack.rb</code></li>
<li>runtime：应用可运行语言的运行时环境。运行时环境的具体信息在配置文件<code>config/runtimes.yml</code>中。@<code>lib/cloud_controller/models/runtime.rb</code></li>
<li>quota：一些共享信息的更新，包括sevice数量，内存限制等。@<code>lib/cloud_controller/models/quota_definition.rb</code></li>
<li>service：存储支持的service信息。@<code>app/models/services/service_broker.rb</code></li>
</ol>
<h2 id="blobstore模块">Blobstore模块</h2>
<p>**注：**blobstor相关源码都@<code>lib/cloud_controller/blobstore</code>文件夹下</p>
<p>Blobstore模块主要负责维护静态文件的存储，这部分文件主要分为三部分：</p>
<ul>
<li>package,通俗的讲即应用程序打包。blobstore会把应用的源码进行压缩，变为package。</li>
<li>buildpack，通俗的讲即程序build时所需环境打包。CCNG的blobstore又把buildpack又分为admin buildpack,cache buildpack两部分。</li>
<li>droplet，通俗的讲即buildpack+package。</li>
</ul>
<p><img src="https://wonderflow.info/images/2014-02-28-cloud_controller_nge6ba90e7a081e99885e8afbbe8aeb0e5bd95/droplet.png" alt="Alt text">
<strong>图2.buildpack、droplet、package结构图 by 薛伟</strong></p>
<p>从如上的工作内容可知Blobstore具体实现内容为：</p>
<ol>
<li>文件的压缩，变为package。@<code>local_app_bits.rb</code> 运行时调用 <code>cloud_controller/safe_zipper.rb</code></li>
<li>文件指纹收集，避免重复备份。采用SHA1的方式。@<code>fingerprints_collection.rb</code></li>
<li>拷贝package到blobstore进行保存，被<code>app_bits_package.rb</code>调用。</li>
<li>blobstore中存储的各种包下载地址的创建。@<code>blobstore_url_generator.rb</code></li>
<li>blobstore中文件的下载 @<code>cdb.rb</code>@<code>blobstore.rb</code></li>
<li>blobstore创建的内容主要由@<code>lib/cloud_controller/dependency_locator.rb</code>调用</li>
</ol>
<h2 id="stager模块">Stager模块</h2>
<p>通过blobstore模块的描述我们知道应用的源码和buildpack进行捆绑打包后的最终形式即为droplet，而负责管理这个过程的组件就是Stager模块。</p>
<p>在Cloud Foundry v1的版本中，整个Cloud Foundry集群只有一个Stager组件。而在Cloud Foundry v2版本中，已经不存在原来独立的Stager组件，而将和Stager功能类似的staging模块设计成DEA的一个子模块。因此，如果v2版本的Cloud Foundry 部署了多个DEA的话，那么该云平台中就会有多个Staging模块。</p>
<p>正是由于有多个Staging模块的缘故，在ccng处设计了一个与这些Staging进行交互的模块，也就是我们这里谈论的CCNG的stager模块。</p>
<p>stager模块分为以下三个部分：</p>
<ol>
<li>
<p><strong>stager_pool</strong>：stager模块维护的资源池，stager_poor会保持与DEA中stager模块的通信，维护最优的5个stager的信息，用来接收和分发有关staging任务的请求。@<code>lib/cloud_controller/stager/stager_poor.rb</code></p>
</li>
<li>
<p><strong>app_stager</strong>: stager模块主要负责处理任务的模块。当app上传的接口收到app_stage命令时，就会调用该模块，该接口@<code>/lib/cloud_controller/api/app.rb</code>。该模块会把app和service进行绑定并向nats发送消息让DEA进行staging的过程，成功staging以后就在blobstore里面存储起来。@<code>lib/cloud_controller/app_stager.rb</code></p>
</li>
<li>
<p><strong>app_stager_task</strong>:CCNG有一个app_observer模块，它会关注app需要进行的动作，包括update、delete。第2点完成以后，update功能会继续stage，调用app_stager_task部分,向nats发送请求。@<code>lib/cloud_controller/app_stager_task.rb</code></p>
</li>
</ol>
<p>一开始看的时候发现第2步和第3步有很多地方函数命名是相同的，觉得很奇怪。后来才知道，第3步就是第2步的延续。所以发送的请求内容是不同的，同时第3步对更新的返回信息有更多的处理。</p>
<p>可以看一下第2步stage_request的代码，此时droplet还未形成：</p>
<p>{% codeblock %}</p>
<pre><code>  def staging_request(app)
    {
      :app_id       =&gt; app.guid,
      :properties   =&gt; staging_task_properties(app),
      :download_uri =&gt; LegacyStaging.app_uri(app.guid),
      :upload_uri   =&gt; LegacyStaging.droplet_upload_uri(app.guid)
    }
  end
</code></pre>
<p>{% endcodeblock %}</p>
<p>第3点的stage_request代码除上述部分外，还要多</p>
<p>{% codeblock %}</p>
<pre><code>:buildpack_cache_download_uri =&gt; @blobstore_url_generator.buildpack_cache_download_url(@app),  
:buildpack_cache_upload_uri =&gt; @blobstore_url_generator.buildpack_cache_upload_url(@app),  
:start_message =&gt; start_app_message,  
:admin_buildpacks =&gt; admin_buildpacks  
</code></pre>
<p>{% endcodeblock %}</p>
<p>同时上传和下载的地址获取方式也已经不同了，因为droplet已经实际存在了：</p>
<p>{% codeblock %}</p>
<pre><code>:download_uri =&gt; @blobstore_url_generator.app_package_download_url(@app),  
:upload_uri =&gt; @blobstore_url_generator.droplet_upload_url(@app),  
</code></pre>
<p>{% endcodeblock %}</p>
<p>同时，app_stage_task在进行stage之前会从stager_pool中找出合适的stager来完成staging任务。</p>
<h2 id="dea模块">DEA模块</h2>
<p>DEA模块的功能是负责CCNG与众DEA之间通信。</p>
<p>在CCNG中，DEA模块也可以大致分为三个部分：</p>
<ol>
<li>
<p><strong>dea_client</strong>：主要负责向DEA发送CCNG收到的相关请求。如：应用的启动、暂停、运行，查找具体的instance信息，应用相关修改等等。同时，它也会向HealthManger模块发送请求查询应用状态。@<code>lib/cloud_controller/dea/dea_client.rb</code></p>
</li>
<li>
<p><strong>dea_respondent</strong>：负责相应并完成由DEA主动发送过来的请求。请求主要是当DEA中的应用退出或意外崩溃时，会由DEA通过NATS向CCNG发送应用退出的消息，从而CCNG可以做后续处理工作。@<code>lib/cloud_controller/dea/dea_respondent.rb</code></p>
</li>
<li>
<p><strong>dea_pool</strong>：负责维护Cloud Foundry中所有DEA的资源池。当Cloud Foundry中有新的DEA启动并开始工作时，都会通过NATS向CCNG发布advertise信息，而CCNG则通过发来的该部分信息向dea_pool中注册DEA信息。当有应用需要启动的时候，CCNG需要找到合适的DEA来完成启动工作，这个时候则由dea_pool通过各DEA的资源使用情况等其他重要条件完成DEAs的筛选，找出符合条件的DEA。@<code>lib/cloud_controller/dea/dea_pool.rb</code></p>
</li>
</ol>
<h2 id="小结app上传流程示意图">小结：APP上传流程示意图</h2>
<p>看完了上述几个模块后，我们可以通过下图进行上述知识的整合。</p>
<p><img src="https://wonderflow.info/images/2014-02-28-cloud_controller_nge6ba90e7a081e99885e8afbbe8aeb0e5bd95/cfpush.png" alt="Alt text">
<strong>图3.APP上传流程示意图 by 薛伟</strong></p>
<p>此图表现的就是执行了<code>$cf push</code>命令（原<code>$vmc push</code>命令）以后，CF集群运作的过程。圆圈中的数字表示执行顺序。</p>
<h2 id="healthmanager模块">HealthManager模块</h2>
<p>HealthManager(以下简称HM)模块主要负责与health_manager建立通信，并完成有关应用健康状态的监控。该部分也可以简单分为两部分：</p>
<ol>
<li>
<p><strong>HealthManagerClient：</strong>：充当CCNG与HM进行通信的client端，通过NATS发消息到HM实现查询指定app的状态、 查找crash的instance、 查看所有app的健康状态这三个功能。@<code>lib/cloud_controller/health_manager_client.rb</code></p>
</li>
<li>
<p><strong>HealthManagerRespondent：</strong>：负责接收CCNG与HM通信过程中health_manager发来启动/停止应用的信息。@<code>lib/cloud_controller/health_manager_respondent.rb</code></p>
</li>
</ol>
<h2 id="service相关模块">Service相关模块</h2>
<p>这个模块的主要代码都在<code>lib/cloud_controller/legacy_api</code>文件夹下，为什么叫legacy这个名字，我至今没有参透。正如该文件夹的名字所言，文件夹下的文件都是对外提供api的，形式就是一个http对应一个执行函数。该模块涉及到Service的只要有3个，LegacyServiceGateway、LegacyServiceLifecycle和LegacyService:</p>
<ol>
<li>
<p><strong>LegacyServiceGateway</strong>：service_gateway对外接口。包括获取所提供的service_gatway信息并更新、根据条件过滤service_gateway信息、删除、更新service_gateway等操作，并在ccdb中进行记录。@<code>lib/cloud_controller/legacy_api/legacy_service_gateway.rb</code></p>
</li>
<li>
<p><strong>LegacyService</strong>：service对外的接口，创建、删除、查找service都通过它。@<code>lib/cloud_controller/legacy_api/legacy_service.rb</code></p>
</li>
<li>
<p><strong>LegacyServiceLifecycle</strong>：上面针对的是service种类，此处针对的是某个service的一个instance的生命周期的管理。@<code>lib/cloud_controller/legacy_api/legacy_service_lifecycle.rb</code></p>
</li>
</ol>
<h2 id="其他api功能一览">其他API功能一览</h2>
<h3 id="libcloud_controllerapi目录下">lib/cloud_controller/api目录下：</h3>
<ul>
<li>
<p>info.rb: 展示集群信息，主要是配置文件上写的信息展示</p>
</li>
<li>
<p>crashes.rb：查看崩溃的应用</p>
</li>
<li>
<p>app_summary.rb：总览各类应用的情况</p>
</li>
<li>
<p><strong>TO BE CONTINUED&hellip;</strong></p>
</li>
</ul>
<hr>
<h2 id="ccng-model图">CCNG Model图</h2>
<p><img src="http://10.10.103.47/gitlab/cf_src_docs/raw/master/pictures/model.png" alt="Alt text"></p>
<hr>
<h1 id="从ccng启动开始的程序细节">从CCNG启动开始的程序细节</h1>
<p>整个项目从可执行脚本bin/cloud_controller开始。</p>
<p>启动命令为：<code>$ ./bin/cloud_controller [-c] [-m] [-d]</code></p>
<p>打开bin/cloud_controller这个文件，前两行就是</p>
<p>{% codeblock %}</p>
<p>$:.unshift(File.expand_path(&quot;../../lib&quot;, <strong>FILE</strong>))
$:.unshift(File.expand_path(&quot;../../app&quot;, <strong>FILE</strong>))</p>
<p>{% endcodeblock %}</p>
<p>这两行的作用就是把项目中lib和app两个文件夹加入到ruby的path路径中，这样就能在后面直接使用require/load调用了。</p>
<p>开始代码是这一行：<code>VCAP::CloudController::Runner.new(ARGV).run!</code></p>
<p>从代码中可以看出调用了Runner模块中的run函数，文件路径为：<code>lib/cloud_controller/runner.rb</code></p>
<p>在执行run!方法前，先经历了一个初始化。默认rack的环境是生产环境，默认配置文件的路径是config/cloud_controller.yml，然后根据参数进行调整。</p>
<p>三个参数分别代表：</p>
<ul>
<li>
<p>-c 设置配置文件读取路径，-c后可指定cloud_controller.yml，代替默认读取的config下的cloud_controller.yml为启动配置文件。</p>
</li>
<li>
<p>-d 进行rack_env设置，把默认的production变成development。程序会执行 register Sinatra::Reloader，动态加载 reload_path 路径下的*.rb文件，这样就可以在不需求重启进程情况下，查看修改后结果，加快开发速度</p>
</li>
<li>
<p>-m 数据库初始化，默认进行 rake db:migrate 后，数据库都是空的，加了-m 选项，cc会在启动的时候将一些默认的值写到数据库中，比如：quota定义等等</p>
</li>
</ul>
<p><strong>启动过程</strong>如下:</p>
<p>{% codeblock %}</p>
<p>def run!
start_cloud_controller
config = @config.dup
Seeds.write_seed_data(config) if @insert_seed_data
app = create_app(config)
start_thin_server(app, config)
end</p>
<p>{% endcodeblock %}</p>
<p>执行create_app之前会做一些初始化工作，包括：</p>
<ol>
<li>cloud_controller初始化：创建pid文件，设置logger，创建和db数据库的连接</li>
<li>steno日志对象初始化</li>
<li>message_bus初始化，所有的subscribe和publish都通过这个对象来进行操作</li>
</ol>
<p><strong>附，初始化配置的相关模块：</strong></p>
<ul>
<li>MessageBus</li>
<li>AccountCapacity</li>
<li>ResourcePool</li>
<li>AppPackage</li>
<li>StagerPool</li>
<li>AppStager</li>
<li>LegacyStaging</li>
<li>DeaPool</li>
<li>DeaClient</li>
<li>LegacyBulk</li>
<li>HealthManagerClient</li>
<li>Models</li>
</ul>
<p>之后通过create_app生成一个Rack::Builder实例,其中有如下关键代码</p>
<p>{% codeblock %}</p>
<p>map &ldquo;/&rdquo; do
run VCAP::CloudController::Controller.new(config)
end</p>
<p>{% endcodeblock %}</p>
<p>map &lsquo;/&lsquo;表示，不管接收到什么http请求，都会调用Controller进行处理。do&hellip;end模块中<a href="http://rack.rubyforge.org/doc/Rack/Builder.html#method-i-run">run这个方法</a>的用法属于sinatra框架的特殊语法。</p>
<p>最后通过start_thin_server启动一个http服务，将生成的Rack::Builder实例传递给该服务器，处理来自客户端的请求。thin_server启动完毕以后，基本上CCNG的启动环节算是结束了。然后进入处理http请求的事件驱动的循环过程。</p>
<p><strong>附，框架相关:</strong></p>
<ul>
<li><a href="(http://rack.rubyforge.org/doc/SPEC.html)">rack</a>是一个用来相应请求的WebServer。</li>
<li><a href="(http://rack.rubyforge.org/doc/SPEC.html)">rack</a>发送过来的请求CCNG采用<a href="(ttp://www.sinatrarb.com/intro.html)">sinatra</a>框架处理</li>
</ul>
<hr>
<h1 id="http请求处理框架">HTTP请求处理框架</h1>
<p>启动的配置以及初始化完毕后，ccng就在thin_server上以一个rack app的形式运行，事件响应则采用sinatra的架构。</p>
<h2 id="controller类">Controller类</h2>
<p><strong>VCAP::CloudController::Controller</strong>继承于Sinatra::Base，是处理所有http请求的入口。</p>
<p>一开始，Controller这个类中定义了<code>before do....end</code>，这个函数会在第一次次接收到请求的时候执行，主要进行用户请求身份验证操作，判断用户是否合法，如果用户验证失败的话，会返回错误信息码。如果成功验证通过，那么会调用VCAP::CloudController::SecurityContext的set方法设置当前登录用户信息，供后面的陆续操作进行权限判断依据。</p>
<p>接下来，http请求根据不同的内容被不同的路由规则引导处理。从程序代码的角度看，这些路由主要被分为自定义路由和默认路由两大块。</p>
<p>通俗的讲：</p>
<ul>
<li>一部分是直接定义在＊.rb文件中，比如 <code>lib/cloud_controller/legacy_api/*.rb</code> 下的所有请求都是直接在脚本中定义get或者post请求处理函数，这种是直观就可以看见的</li>
<li>还有一部分，是通过回调<code>lib/cloud_controller/rest_controller.rb</code>中的self.rest_controller这个方法，这个方法里面有一个define_routes，来定义get，post，delete，put请求，并通过调用api的dispatch函数来进行选择具体的处理函数.</li>
</ul>
<h3 id="自定义路由">自定义路由</h3>
<p>自定义路由即文件被载入(require)到Controller模块时，就是rack框架可识别的路由信息。这样自定义的路由信息都被写成类似如下的格式：(以lib/cloud_controller/api/app_bits.rb为例)</p>
<p>{% codeblock %}</p>
<p>module VCAP::CloudController
rest_controller :AppBits do
&hellip;&hellip;
end
end</p>
<p>{% endcodeblock %}</p>
<p>这其中，起到关键作用的就是rest_contoller这个宏定义方法，在require文件app_bits.rb时（或者说执行到这里时），会将其后的内容展开。rest_controller定义在lib/cloud_controller/rest_controller.rb中</p>
<p>{% codeblock %}</p>
<p>def self.rest_controller(name, &amp;blk;)
# Class.new：生成一个无名的superclass的子类. 若superclass不存在则生成Object的子类.
# 这里的superclass应该是RestController::ModelController, Base的子类，include了routes
klass = Class.new RestController::ModelController
# const_set：在模块中，定义一个名为name且值为value的常数后返回value
self.const_set name, klass
# class_eval：添加方法
# class_eval若带块的话，会把新生成的类传给块参数，然后在类的context中执行该块。
klass.class_eval &amp;blk;</p>
<pre><code># 执行了disable_default_routes的类都有自己定义的route
if klass.default_routes?
# 否则绝大多数类都有attribute之类的语句
  klass.class_eval do
    define_messages
    define_routes
  end
end
</code></pre>
<p>end</p>
<p>{% endcodeblock %}</p>
<p>对于app_bits.rb，参数name就是:AppBits，blk就是do&hellip;end部分的内容。首先动态生成一个类，然后执行klass.class_eval将blk中的方法添加为自己的方法。添加方法的同时会执行blk。</p>
<p>对于app_bits.rb来说，通过def&hellip;end定义的方法不会被执行，如upload、download等。而独立于方法定义之外的是语句可执行的。如</p>
<p>{% codeblock %}</p>
<p>disable_default_routes
put &ldquo;#{path_id}/bits&rdquo;, :upload
get &ldquo;#{path_id}/download&rdquo;, :download</p>
<p>{% endcodeblock %}</p>
<p>等等。</p>
<p>由此可以看出，这种路由配置实际上是一个方法的执行。以<code>put &quot;#{path_id}/bits&quot; :upload</code>为例，其方法是<code>put</code>，参数是<code>&quot;#{path_id}/bits&quot;</code>和<code>:upload</code>。这里的<code>put</code>方法也是在<code>lib/cloud_controller/rest_controller/routes.rb</code>中定义的</p>
<p>{% codeblock %}</p>
<p>[:post, :get, :put, :delete].each do |verb|
define_method(verb) do |*args, &amp;blk;|
(path, method) = *args
define_route(verb, path, method, &amp;blk;)
end
end</p>
<p>{% endcodeblock %}</p>
<p>这里同时定义了4个方法，包括<code>put</code>。每一个方法的功能又是定义一个方法。对于<code>put</code>，该方法的名字为<code>put</code>，参数为<code>args</code>和<code>blk</code>，在<code>put &quot;#{path_id}/bits&quot;, :upload</code>中，args是<code>&quot;#{path_id}/bits&quot;, :upload</code>，blk为<code>nil</code>。进一步解析为，path=<code>&quot;#{path_id}/bits&quot;</code>，method=<code>&quot;upload&quot;</code>。然后执行<code>define_route(&quot;put&quot;, &quot;#{path_id}/bits&quot;, &quot;upload&quot;)</code>。
define_route定义在<code>lib/cloud_controller/rest_controller/routes.rb</code>中</p>
<p>{% codeblock %}</p>
<p>def define_route(verb, path, method = nil, &amp;blk;)
opts = {}
opts[:consumes] = [:json] if [:put, :post].include?(verb)
klass = self    <br>
controller.send(verb, path, opts) do |*args|     <br>
logger.debug &ldquo;dispatch #{klass} #{verb} #{path}&rdquo;  <br>
api = klass.new(@config, logger, env, request.params, request.body, self)
if method
# dispatch定义在Base中
api.dispatch(method, *args)
else
blk.yield(api, *args)
end
end
end</p>
<p>{% endcodeblock %}</p>
<p>controller就定义在本文件中，<code>controller.class=Class.send</code>若是带块调用的话,也会把块原封不动地传给方法，于是就执行<code>put &quot;#{path_id}/bits&quot; do...end</code>，这时还不知道如何执行put，所以就展开放在这里，成了rack可读的形式。
send后面有一个参数*args实际上是:guid，这是。Sinatra框架中，路由范式可以包括具名参数。例如</p>
<p>{% codeblock %}
<code>get '/:path/:name' do |n, m| &quot;path= #{n}; name= #{m}\n&quot; end</code>
{% endcodeblock %}</p>
<p>path展开到最底层，只有一个具名参数:guid，于是*args就是:guid。</p>
<p>参数env和request是<code>Sinatra::Base</code>的成员，其中env包括很多内容，例如<code>REQUEST_URI，REMOTE_ADDR</code>等等。因为当前类间接地继承了<code>Sinatra::Base</code>，所以可以使用这些变量。</p>
<p>最后，路由<code>put &quot;#{path_id}/bits&quot;, :upload</code>就被翻译为，遇到put请求，路径为<code>&quot;#{path_id}/bits&quot;</code>，则调用<code>upload</code>处理，同时将<code>:guid</code>传递给<code>upload</code>。</p>
<h3 id="默认路由">默认路由</h3>
<p>app.rb及其他一些文件中，没有调用<code>disable_default_routes</code>，在执行到rest_controller时，会调用define_routes来定义自己的路由。通过define_routes创建的路由具有一定的相似性，源文件只需给出路径名的一部分，其他部分在define_routes中动态生成，因此称为默认路由。</p>
<p>{% codeblock %}
<code>  def define_routes define_standard_routes define_to_many_routes end</code>
{% endcodeblock %}</p>
<p><code>define_standard_routes</code>和<code>define_to_many_routes</code>定义在同名文件中。</p>
<p>{% codeblock %}
<code>  def define_standard_routes [ [:post,   path,    :create], [:get,    path,    :enumerate], [:get,    path_id, :read], [:put,    path_id, :update], [:delete, path_id, :delete] ].each do |verb, path, method| define_route(verb, path, method) end end</code>
{% endcodeblock %}</p>
<p>define_standard_routes生成一些相对固定的路由。当有path时，路由为path，方法为post和get；当有path_id时，路由为path_id，方法为get，put和delete。path定义在<code>lib/cloud_controller/rest_controller/base.rb</code>中</p>
<p>{% codeblock %}
`  def path
&ldquo;#{ROUTE_PREFIX}/#{path_base}&rdquo;
end</p>
<h1 id="get-and-set-the-base-of-the-path-for-the-api-endpoint">Get and set the base of the path for the api endpoint.</h1>
<h1 id="heading"></h1>
<h1 id="param-string-base-path-to-the-api-endpoint-eg-the-apps-part-of">@param [String] base path to the api endpoint, e.g. the apps part of</h1>
<h1 id="v2apps">/v2/apps/&hellip;</h1>
<h1 id="heading-1"></h1>
<h1 id="return-string-base-path-to-the-api-endoint">@return [String] base path to the api endoint</h1>
<p>def path_base(base = nil)
@path_base = base if base
@path_base || class_basename.underscore.pluralize
end</p>
<h1 id="basename-of-the-class">basename of the class</h1>
<h1 id="heading-2"></h1>
<h1 id="return-string-basename-of-the-class">@return [String] basename of the class</h1>
<p>def class_basename
self.name.split(&quot;::&quot;).last
end
`
{% endcodeblock %}</p>
<p>当类的源文件中调用了path_base时，则@path_base为传入的参数；否则@path_base为类名做如下变化的结果：将大写字母改为小写，然后将单数形式改为复数形式。例如，对于app.rb，path展开后的形式为/v2/apps，而对于app_bits.rb，path展开后的形式也为/v2/apps。</p>
<p>(为什么有/v2？   因为<code>ROUTE_PREFIX = &quot;/v2&quot;</code>)</p>
<p>path_id定义在<code>lib/cloud_controller/rest_controller/model_controller.rb</code>中。</p>
<p>{% codeblock %}
<code>  def path_id &quot;#{path}/:guid&quot; end</code>
{% endcodeblock %}</p>
<p>其中:guid为具名参数（关于具名参数&rsquo;named parameters&rsquo;的意思可参考博客<a href="http://www.sitepoint.com/just-do-it-learn-sinatra-i/">Just Do It: Learn Sinatra, Part One</a>），根据请求内容而定。
至此，结合前面的分析，define_standard_routes的调用结果就显而易见了。例如app.rb，会生成下面这些路由</p>
<p>{% codeblock %}
<code>post  &quot;/v2/apps&quot;  create get  &quot;/va/apps&quot;  enumerate get  &quot;/v2/apps/:guid&quot;  read put  &quot;/v2/apps/:guid&quot;  update delete  &quot;/v2/apps/:guid&quot;  delete</code>
{% endcodeblock %}</p>
<p>create等操作定义在lib/cloud_controller/rest_controller/model_controller.rb中。</p>
<p>define_routes接下来还要调用define_to_many_routes。</p>
<p>{% codeblock %}</p>
<p>def define_to_many_routes     <br>
to_many_relationships.each do |name, attr|</p>
<pre><code>  get &quot;#{path_id}/#{name}&quot; do |api, id|
    api.dispatch(:enumerate_related, id, name)
  end

  put &quot;#{path_id}/#{name}/:other_id&quot; do |api, id, other_id|
    api.dispatch(:add_related, id, name, other_id)
  end

  delete &quot;#{path_id}/#{name}/:other_id&quot; do |api, id, other_id|
    api.dispatch(:remove_related, id, name, other_id)
  end
end
</code></pre>
<p>end</p>
<p>{% endcodeblock %}</p>
<p>如果说define_standard_routes用来解析由path和path_id定义的路由，那么define_to_many_routes就是用来解析通过to_many定义的路由。
以<code>lib/cloud_controller/api/space.rb</code>为例，其中有一段</p>
<p>{% codeblock %}
<code>define_attributes do attribute  :name,            String to_one     :organization to_many    :developers to_many    :managers to_many    :auditors to_many    :apps to_many    :domains to_many    :service_instances to_many    :app_events end</code>
{% endcodeblock %}</p>
<p>当启动时执行到这里时，就会调用define_attributes方法。define_attributes定义在lib/cloud_controller/rest_controller/model_controller.rb中</p>
<p>{% codeblock %}
<code>  def define_attributes(&amp;blk) k = Class.new do include ControllerDSL end # instance_eval：在对象的context中计算字符串expr并返回结果 k.new(self).instance_eval_r(&amp;blk) end</code>
{% endcodeblock %}</p>
<p>于是会执行attribute，to_one和to_many这些方法。其中to_many定义在<code>lib\cloud_controller\rest_controller\controller_dsl.rb</code>中。</p>
<p>{% codeblock %}
<code>def to_many(name, opts = {}) to_many_relationships[name] = ToManyAttribute.new(name, opts) end</code>
{% endcodeblock %}</p>
<p>对于space.rb中的to_many    :apps来说，展开为</p>
<p>{% codeblock %}
<code>to_many_relationships[&quot;:apps&quot;] = ToManyAttribute.new(&quot;:apps&quot;, opts)</code>
{% endcodeblock %}</p>
<p>也就是新建一个类，添加到to_many_relationships中。根据上下文，to_many_relationships是一个Array或一个Hash结构。</p>
<p>执行到define_to_many_routes时，each后的参数name就是apps。api和id是路由范式中的具名参数。</p>
<p>以路由<code>&quot;#{path_id}/#{name}&quot;</code>为例，path_id中包括两个变量，如果一个请求和该路由匹配，则第一个变量的实际值将赋给api，第二个变量的实际值赋给id。在另外两个路由范式中，:other_id代表第三个变量。第一个变量是什么还不知道，但通过测试可知，:guid部分的内容会被赋给id，那么第一个具名参数一定在path_id中。而api在运行过程中代表一个类的实例。例如，在启动时一个路由最终展开为<code>#{path_id} /v2/spaces/:guid</code>。当一个URL匹配该路由时，参数值如下</p>
<p>{% codeblock %}</p>
<p>api=#
id=81243e10-9b28-411e-9ccf-524ab15ce37c
#{name}=apps</p>
<p>{% endcodeblock %}</p>
<p>通过define_standard_routes定义的路由，其具名参数放在*args中，数量可以是一个。</p>
<h2 id="处理请求的过程">处理请求的过程</h2>
<p>以客户启动一个APP为例。</p>
<p>当客户端启动一个app时，发送的请求的格式如下（实际上客户端先检查app的状态，然后才决定是否发送put请求，这里假设app当前状态为stopped，因此客户端需要发送put请求）</p>
<p><code>PUT /v2/apps/:guid?stage_async=true</code></p>
<p>通过前面的分析可知，该请求和一个通过define_standard_routes定义的路由匹配，并被<code>lib/cloud_controller/rest_controller/model_controller.rb</code>的update方法处理。</p>
<p>{% codeblock %}</p>
<pre><code>def update(id)
</code></pre>
<p>date = &quot;&quot;
slug = &ldquo;/cloud_controller_nge6ba90e7a081e99885e8afbbe8aeb0e5bd95&rdquo;
obj = find_id_and_validate_access(:update, id)
json_msg = self.class::UpdateMessage.decode(body)
@request_attrs = json_msg.extract(:stringify_keys =&gt; true)
raise InvalidRequest unless request_attrs\</p>
<pre><code>  before_modify(obj)
  
  model.db.transaction do
    obj.lock!
    obj.update_from_hash(request_attrs)
  end

  after_modify(obj)

  [HTTP::CREATED, serialization.render_json(self.class, obj, @opts)]
end
</code></pre>
<p>{% endcodeblock %}</p>
<p>其参数即是url中的guid。find_id_and_validate_access会调用<code>obj = model.find(:guid =&gt; id)</code>得到一个Sequel::Model对象并加以验证，如果合法则返回该对象。</p>
<p>Sequel 是一个 Ruby 语言的对象映射框架（ORM），其子类Sequel::Model代表一种对象关系映射。而find_id_and_validate_access返回的Sequel::Model对象相当于数据库中的一行，:guid =&gt; id即是查询条件。</p>
<p>obj.update_from_hash根据请求中body中的内容更新数据库。在操作前后分别调用了before_modify和after_modify方法，其中before_modify定义如下</p>
<p>{% codeblock %}
<code>def before_modify(app) app.stage_async = %w(1 true).include?(params[&quot;stage_async&quot;]) end</code>
{% endcodeblock %}</p>
<p>根据put请求的内容，执行before_modify后app.stage_async会变为true。当update_from_hash这个事物成功后，会调用<code>lib/cloud_controller/models/app.rb</code>中的after_commit，其中涉及到对该标志位的检查。</p>
<p>{% codeblock %}
`  def after_commit
super
react_to_saved_changes(previous_changes || {})
end</p>
<p>def react_to_saved_changes(changes)
if changes.has_key?(:state)
react_to_state_change
elsif changes.has_key?(:instances)
delta = changes[:instances][1] - changes[:instances][0]
react_to_instances_change(delta)
end
end
`
{% endcodeblock %}</p>
<p>在after_commit中调用react_to_saved_changes，执行数据库更新后应该做的一些操作。react_to_saved_changes首先检查changes这个参数，看其是否包含:state关键字。当app在数据库中的状态由stopped变为started时，changes会记录该变化，于是执行react_to_state_change。</p>
<p>{% codeblock %}
<code>  def react_to_state_change if started? stage_if_needed do DeaClient.start(self) send_droplet_updated_message end elsif stopped? DeaClient.stop(self) send_droplet_updated_message end end</code>
{% endcodeblock %}</p>
<p>react_to_state_change判断状态是不是“STARTED”，结果为真，于是执行if后的语句。如果需要，则先执行stage操作，然后调用DeaClient.start和send_droplet_updated_message。send_droplet_updated_message向nats中发送droplet.updated消息，DeaClient.start开始启动一个app的过程。</p>
<p>{% codeblock %}</p>
<pre><code>  def start(app)
    start_instances_in_range(app, (0...app.instances))
    app.routes_changed = false
  end
  
  def start_instances_in_range(app, indices)
    start_instances_with_message(app, indices, {})
  end
  
  def start_instances_with_message(app, indices, message_override)
    msg = start_app_message(app)

    indices.each do |idx|
      msg[:index] = idx
      dea_id = dea_pool.find_dea(app.memory, app.stack.name, app.guid)
      if dea_id
        dea_publish(&quot;#{dea_id}.start&quot;, msg.merge(message_override))
        dea_pool.mark_app_staged(dea_id: dea_id, app_id: app.guid)
      else
        logger.error &quot;no resources available #{msg}&quot;
      end
    end
  end
</code></pre>
<p>{% endcodeblock %}</p>
<p>start_instances_with_message的第一个参数是app名字，第二个参数是实例个数，controller从dea_pool中找到一个dea，通过nats向主题<code>#{dea_id}.start</code>发送消息。<code>#{dea_id}</code>对应的dea收到消息后，就会执行启动app的操作。</p>
<hr>
<h1 id="一些大家可能感兴趣的细节">一些大家可能感兴趣的细节</h1>
<h2 id="cloud_controlleryml文件">cloud_controller.yml文件</h2>
<ol>
<li>
<p>CCNG统一使用8181作为统一对外开放的端口，原CC的端口为9022.</p>
</li>
<li>
<p>info包含了如下默认信息，包括版本号、描述等。其中，support_address默认为&quot;http://support.cloudfoundry.com&quot; description默认为 &ldquo;VMware&rsquo;s Cloud Application Platform&rdquo;</p>
</li>
<li>
<p>db包含了和CCDB的最大连接数和超时时间的设置.</p>
</li>
<li>
<p>staging字段包含了最大stage时间，默认为120s，如果上传的应用大，需要修改配置.</p>
</li>
</ol>
<h2 id="to-be-continued">TO BE CONTINUED&hellip;</h2>
<hr>
<h1 id="参考文献">参考文献</h1>
<ul>
<li>
<p><a href="https://github.com/cloudfoundry/cloud_controller_ng">Cloud_Controller_NG github源码</a></p>
</li>
<li>
<p><a href="http://blog.sina.com.cn/s/blog_c0cc23d90101otot.html">Cloud_Controller_ng源码分析</a></p>
</li>
<li>
<p><a href="http://blog.csdn.net/tibelf/article/details/13295443">cloud controller v2源码解析</a></p>
</li>
<li>
<p><a href="http://blog.csdn.net/shlazww/article/details/18887607">Cloud Foundry中cloud_controller_ng架构简析</a></p>
</li>
</ul>
<hr>
<h1 id="licence">Licence</h1>
<p>转载请注明出处 ZJU——SEL——LAB <a href="http://wonderflow.info">@wonderflow</a></p>
<hr>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/ccng" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">ccng</a>
   </li>
  
   <li class="list">
     <a href="/tags/cf" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">cf</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
    </div>
  </div>

  <aside class="w-30-l mt6-l">




</aside>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
    <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://wonderflow.info">
      &copy;  奇迹之流WonderfloW 2021 
    </a>
    <div>








<a href="https://github.com/wonderflow" target="_blank" class="link-transition github link dib z-999 pt3 pt0-l mr1" title="Github link" rel="noopener" aria-label="follow on Github——Opens in a new window">
  <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>







</div>
    <a href="https://beian.miit.gov.cn/" class="link db f6 pa2 br3 bg-mid-gray white dim w4 tc"> 沪ICP备2020029591号 </a>
  </div>
</footer>
    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
