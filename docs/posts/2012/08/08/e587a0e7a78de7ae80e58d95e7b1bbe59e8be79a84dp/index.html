<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>几种简单类型的动态规划 | 奇迹之流WonderfloW</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="今天又被鱼头拉着校验集训队的书，正好看了一下动态规划(DP)这块，顺便总结一下。发现几道POJ上的例题正好是自己没有做过的，正好拿来试试手，写写题解。
线性动态规划：
1、最长递增（减）子序列：给出一个数列，求最长不下降（上升）子序列的长度。poj2533
这个经典的DP问题有两种解法，复杂度分别为O（n^2）和O（nlogn）。
O(n^2)的算法比较容易理解，就是用dp[i]表示数列到i位置的最长递增（减）子序列的长度。
第一重循环自然就是枚举i的位置，第二重循环就是从0到i-1，选择一个数字比num[i]小（大）的数的dp值加1，看能否更新dp[i]。
以最长递增子序列为例，就是dp[i] = max(dp[j]&#43;1),(j=0..i-1,且num[j] &lt; num[i])。
#include&lt;iostream&gt;
using namespace std;
int n,k,c,ans[1100],maxx,i,j,data[1100];
int main(){
	cin&gt;&gt;n;
	for(i=0;i&lt;n;i&#43;&#43;)cin&gt;&gt;data[i];
	ans[0]=1;
	for(i=1;i&lt;n;i&#43;&#43;){
		ans[i]=1;
		for(j=0;j&lt;i;j&#43;&#43;){
			if(data[j]&lt;data[i] &amp;&amp; ans[j]&#43;1&gt;ans[i])
				ans[i] = ans[j] &#43; 1;
		}
	}
	maxx=1;
	for(i=0;i&lt;n;i&#43;&#43;)if(ans[i]&gt;maxx)maxx=ans[i];
	cout&lt;&lt;maxx;
}
O（nlogn）的算法其实就是针对O（n^2）算法中的第二重循环进行优化，还是以最长递增子序列为例，我们维护一个待选序列ls，这个序列满足ls[i]中存放的就是最长递增子序列为长度i的数列中最大的一个元素。换句话说，到最后，ls数组有多长，最长递增子序列就有多长。
然后我们会发现，ls数组本身就是一组符合条件的最长递增子序列的解，里面的数本身就是有序的，然后更新的时候，我们就可以用到二分查找来进行优化了。
一开始的时候，ls数组长度为0，数字自动填充到ls数组中的第一个位置，长度变为1，然后后面每来一个数，都用二分搜索，找到ls数组中比当前插入值大的最小一个数的位置，然后替换它，如果找不到（即当前要插入的值是最大的），自然就是添加到ls数组末尾，使数组长度增加。
因为我是按照原始数组的顺序进行DP的，那么我当前要插入的值要找到在最终答案里的位置，由于是最长递增序列，那么我前面的数一定比我小，所以我插入的位置一定就是恰好所有前面的数都比我小的位置，替换掉的就是跟我有相同递增长度的那个值，但是我比那个数小，更有前途与后面的数构成更长的递增子序列。
////二分查找优化 nlogn
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#define MAX 1005
int f[MAX];
int i,j,ans,n;
int left,right,x,mid;
int main(){
    scanf(&#34;%d&#34;,&amp;n);
    ans=0;
    for (i=1; i&lt;=n ; i&#43;&#43;){
        scanf(&#34;%d&#34;,&amp;x);
        left=1;
        right=ans;
        while (left&lt;right){
            mid=(left&#43;right)/2;
            if (f[mid]&lt;x) left=mid&#43;1;
            else right=mid;
        }
        if (left&gt;=right&amp;&amp;x&gt;f[ans]||ans==0){
            ans&#43;&#43;;
            f[ans]=x;
        }
        else if (x&lt;f[left]){
            f[left]=x;
        }
    }
    printf(&#34;%d\n&#34;,ans);
    return 0;
}
2、最长公共子序列：求两个字符串的最长公共子序列的长度。 poj1458">
    <meta name="generator" content="Hugo 0.153.4">
    
    
    
      <meta name="robots" content="index, follow">
    
    <meta name="author" content="admin">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.efe4d852f731d5d1fbb87718387202a97aafd768cdcdaed0662bbe6982e91824.css" >



  
    <link rel="stylesheet" href="/css/custom.css">
  


    


    
      
<link rel="shortcut icon" href="/favicon_io/favicon.ico" type="image/x-icon" />


    

    

    
      <link rel="canonical" href="https://wonderflow.info/posts/2012/08/08/e587a0e7a78de7ae80e58d95e7b1bbe59e8be79a84dp/">
    

    
    
    <meta property="og:url" content="https://wonderflow.info/posts/2012/08/08/e587a0e7a78de7ae80e58d95e7b1bbe59e8be79a84dp/">
  <meta property="og:site_name" content="奇迹之流WonderfloW">
  <meta property="og:title" content="几种简单类型的动态规划">
  <meta property="og:description" content="今天又被鱼头拉着校验集训队的书，正好看了一下动态规划(DP)这块，顺便总结一下。发现几道POJ上的例题正好是自己没有做过的，正好拿来试试手，写写题解。
线性动态规划： 1、最长递增（减）子序列：给出一个数列，求最长不下降（上升）子序列的长度。poj2533 这个经典的DP问题有两种解法，复杂度分别为O（n^2）和O（nlogn）。
O(n^2)的算法比较容易理解，就是用dp[i]表示数列到i位置的最长递增（减）子序列的长度。 第一重循环自然就是枚举i的位置，第二重循环就是从0到i-1，选择一个数字比num[i]小（大）的数的dp值加1，看能否更新dp[i]。 以最长递增子序列为例，就是dp[i] = max(dp[j]&#43;1),(j=0..i-1,且num[j] &lt; num[i])。
#include&lt;iostream&gt; using namespace std; int n,k,c,ans[1100],maxx,i,j,data[1100]; int main(){ cin&gt;&gt;n; for(i=0;i&lt;n;i&#43;&#43;)cin&gt;&gt;data[i]; ans[0]=1; for(i=1;i&lt;n;i&#43;&#43;){ ans[i]=1; for(j=0;j&lt;i;j&#43;&#43;){ if(data[j]&lt;data[i] &amp;&amp; ans[j]&#43;1&gt;ans[i]) ans[i] = ans[j] &#43; 1; } } maxx=1; for(i=0;i&lt;n;i&#43;&#43;)if(ans[i]&gt;maxx)maxx=ans[i]; cout&lt;&lt;maxx; } O（nlogn）的算法其实就是针对O（n^2）算法中的第二重循环进行优化，还是以最长递增子序列为例，我们维护一个待选序列ls，这个序列满足ls[i]中存放的就是最长递增子序列为长度i的数列中最大的一个元素。换句话说，到最后，ls数组有多长，最长递增子序列就有多长。 然后我们会发现，ls数组本身就是一组符合条件的最长递增子序列的解，里面的数本身就是有序的，然后更新的时候，我们就可以用到二分查找来进行优化了。 一开始的时候，ls数组长度为0，数字自动填充到ls数组中的第一个位置，长度变为1，然后后面每来一个数，都用二分搜索，找到ls数组中比当前插入值大的最小一个数的位置，然后替换它，如果找不到（即当前要插入的值是最大的），自然就是添加到ls数组末尾，使数组长度增加。 因为我是按照原始数组的顺序进行DP的，那么我当前要插入的值要找到在最终答案里的位置，由于是最长递增序列，那么我前面的数一定比我小，所以我插入的位置一定就是恰好所有前面的数都比我小的位置，替换掉的就是跟我有相同递增长度的那个值，但是我比那个数小，更有前途与后面的数构成更长的递增子序列。
////二分查找优化 nlogn #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;math.h&gt; #define MAX 1005 int f[MAX]; int i,j,ans,n; int left,right,x,mid; int main(){ scanf(&#34;%d&#34;,&amp;n); ans=0; for (i=1; i&lt;=n ; i&#43;&#43;){ scanf(&#34;%d&#34;,&amp;x); left=1; right=ans; while (left&lt;right){ mid=(left&#43;right)/2; if (f[mid]&lt;x) left=mid&#43;1; else right=mid; } if (left&gt;=right&amp;&amp;x&gt;f[ans]||ans==0){ ans&#43;&#43;; f[ans]=x; } else if (x&lt;f[left]){ f[left]=x; } } printf(&#34;%d\n&#34;,ans); return 0; } 2、最长公共子序列：求两个字符串的最长公共子序列的长度。 poj1458">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2012-08-08T10:44:28+00:00">
    <meta property="article:modified_time" content="2012-08-08T10:44:28+00:00">
    <meta property="article:tag" content="DP">
    <meta property="article:tag" content="Poj">
    <meta property="article:tag" content="解题报告">

  <meta itemprop="name" content="几种简单类型的动态规划">
  <meta itemprop="description" content="今天又被鱼头拉着校验集训队的书，正好看了一下动态规划(DP)这块，顺便总结一下。发现几道POJ上的例题正好是自己没有做过的，正好拿来试试手，写写题解。
线性动态规划： 1、最长递增（减）子序列：给出一个数列，求最长不下降（上升）子序列的长度。poj2533 这个经典的DP问题有两种解法，复杂度分别为O（n^2）和O（nlogn）。
O(n^2)的算法比较容易理解，就是用dp[i]表示数列到i位置的最长递增（减）子序列的长度。 第一重循环自然就是枚举i的位置，第二重循环就是从0到i-1，选择一个数字比num[i]小（大）的数的dp值加1，看能否更新dp[i]。 以最长递增子序列为例，就是dp[i] = max(dp[j]&#43;1),(j=0..i-1,且num[j] &lt; num[i])。
#include&lt;iostream&gt; using namespace std; int n,k,c,ans[1100],maxx,i,j,data[1100]; int main(){ cin&gt;&gt;n; for(i=0;i&lt;n;i&#43;&#43;)cin&gt;&gt;data[i]; ans[0]=1; for(i=1;i&lt;n;i&#43;&#43;){ ans[i]=1; for(j=0;j&lt;i;j&#43;&#43;){ if(data[j]&lt;data[i] &amp;&amp; ans[j]&#43;1&gt;ans[i]) ans[i] = ans[j] &#43; 1; } } maxx=1; for(i=0;i&lt;n;i&#43;&#43;)if(ans[i]&gt;maxx)maxx=ans[i]; cout&lt;&lt;maxx; } O（nlogn）的算法其实就是针对O（n^2）算法中的第二重循环进行优化，还是以最长递增子序列为例，我们维护一个待选序列ls，这个序列满足ls[i]中存放的就是最长递增子序列为长度i的数列中最大的一个元素。换句话说，到最后，ls数组有多长，最长递增子序列就有多长。 然后我们会发现，ls数组本身就是一组符合条件的最长递增子序列的解，里面的数本身就是有序的，然后更新的时候，我们就可以用到二分查找来进行优化了。 一开始的时候，ls数组长度为0，数字自动填充到ls数组中的第一个位置，长度变为1，然后后面每来一个数，都用二分搜索，找到ls数组中比当前插入值大的最小一个数的位置，然后替换它，如果找不到（即当前要插入的值是最大的），自然就是添加到ls数组末尾，使数组长度增加。 因为我是按照原始数组的顺序进行DP的，那么我当前要插入的值要找到在最终答案里的位置，由于是最长递增序列，那么我前面的数一定比我小，所以我插入的位置一定就是恰好所有前面的数都比我小的位置，替换掉的就是跟我有相同递增长度的那个值，但是我比那个数小，更有前途与后面的数构成更长的递增子序列。
////二分查找优化 nlogn #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;math.h&gt; #define MAX 1005 int f[MAX]; int i,j,ans,n; int left,right,x,mid; int main(){ scanf(&#34;%d&#34;,&amp;n); ans=0; for (i=1; i&lt;=n ; i&#43;&#43;){ scanf(&#34;%d&#34;,&amp;x); left=1; right=ans; while (left&lt;right){ mid=(left&#43;right)/2; if (f[mid]&lt;x) left=mid&#43;1; else right=mid; } if (left&gt;=right&amp;&amp;x&gt;f[ans]||ans==0){ ans&#43;&#43;; f[ans]=x; } else if (x&lt;f[left]){ f[left]=x; } } printf(&#34;%d\n&#34;,ans); return 0; } 2、最长公共子序列：求两个字符串的最长公共子序列的长度。 poj1458">
  <meta itemprop="datePublished" content="2012-08-08T10:44:28+00:00">
  <meta itemprop="dateModified" content="2012-08-08T10:44:28+00:00">
  <meta itemprop="wordCount" content="389">
  <meta itemprop="keywords" content="DP,Poj,解题报告">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="几种简单类型的动态规划">
  <meta name="twitter:description" content="今天又被鱼头拉着校验集训队的书，正好看了一下动态规划(DP)这块，顺便总结一下。发现几道POJ上的例题正好是自己没有做过的，正好拿来试试手，写写题解。
线性动态规划： 1、最长递增（减）子序列：给出一个数列，求最长不下降（上升）子序列的长度。poj2533 这个经典的DP问题有两种解法，复杂度分别为O（n^2）和O（nlogn）。
O(n^2)的算法比较容易理解，就是用dp[i]表示数列到i位置的最长递增（减）子序列的长度。 第一重循环自然就是枚举i的位置，第二重循环就是从0到i-1，选择一个数字比num[i]小（大）的数的dp值加1，看能否更新dp[i]。 以最长递增子序列为例，就是dp[i] = max(dp[j]&#43;1),(j=0..i-1,且num[j] &lt; num[i])。
#include&lt;iostream&gt; using namespace std; int n,k,c,ans[1100],maxx,i,j,data[1100]; int main(){ cin&gt;&gt;n; for(i=0;i&lt;n;i&#43;&#43;)cin&gt;&gt;data[i]; ans[0]=1; for(i=1;i&lt;n;i&#43;&#43;){ ans[i]=1; for(j=0;j&lt;i;j&#43;&#43;){ if(data[j]&lt;data[i] &amp;&amp; ans[j]&#43;1&gt;ans[i]) ans[i] = ans[j] &#43; 1; } } maxx=1; for(i=0;i&lt;n;i&#43;&#43;)if(ans[i]&gt;maxx)maxx=ans[i]; cout&lt;&lt;maxx; } O（nlogn）的算法其实就是针对O（n^2）算法中的第二重循环进行优化，还是以最长递增子序列为例，我们维护一个待选序列ls，这个序列满足ls[i]中存放的就是最长递增子序列为长度i的数列中最大的一个元素。换句话说，到最后，ls数组有多长，最长递增子序列就有多长。 然后我们会发现，ls数组本身就是一组符合条件的最长递增子序列的解，里面的数本身就是有序的，然后更新的时候，我们就可以用到二分查找来进行优化了。 一开始的时候，ls数组长度为0，数字自动填充到ls数组中的第一个位置，长度变为1，然后后面每来一个数，都用二分搜索，找到ls数组中比当前插入值大的最小一个数的位置，然后替换它，如果找不到（即当前要插入的值是最大的），自然就是添加到ls数组末尾，使数组长度增加。 因为我是按照原始数组的顺序进行DP的，那么我当前要插入的值要找到在最终答案里的位置，由于是最长递增序列，那么我前面的数一定比我小，所以我插入的位置一定就是恰好所有前面的数都比我小的位置，替换掉的就是跟我有相同递增长度的那个值，但是我比那个数小，更有前途与后面的数构成更长的递增子序列。
////二分查找优化 nlogn #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;math.h&gt; #define MAX 1005 int f[MAX]; int i,j,ans,n; int left,right,x,mid; int main(){ scanf(&#34;%d&#34;,&amp;n); ans=0; for (i=1; i&lt;=n ; i&#43;&#43;){ scanf(&#34;%d&#34;,&amp;x); left=1; right=ans; while (left&lt;right){ mid=(left&#43;right)/2; if (f[mid]&lt;x) left=mid&#43;1; else right=mid; } if (left&gt;=right&amp;&amp;x&gt;f[ans]||ans==0){ ans&#43;&#43;; f[ans]=x; } else if (x&lt;f[left]){ f[left]=x; } } printf(&#34;%d\n&#34;,ans); return 0; } 2、最长公共子序列：求两个字符串的最长公共子序列的长度。 poj1458">

      
      
    
	
  </head><body class="ma0 avenir production">

    

  <header>
    <div class="bg-near-white">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        奇迹之流WonderfloW
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/about/" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/archives/" title="Archives page">
              Archives
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>
    </div>
  </header>


    <main class="pb7" role="main">
      
<div class="flex-l mt2 mw8 center">
  <article class="center cf pv5 ph3 ph4-ns mw7">
    <header>
      <p class="f6 b helvetica tracked">
        POSTS
      </p>
      <h1 class="f1">
        几种简单类型的动态规划
      </h1>
    </header>
    <div class="nested-copy-line-height lh-copy f4 nested-links nested-img mid-gray">
      <p>今天又被鱼头拉着校验集训队的书，正好看了一下动态规划(DP)这块，顺便总结一下。发现几道POJ上的例题正好是自己没有做过的，正好拿来试试手，写写题解。</p>
<p><strong>线性动态规划：</strong>
1、最长递增（减）子序列：给出一个数列，求最长不下降（上升）子序列的长度。<a href="http://poj.org/problem?id=2533">poj2533</a>
这个经典的DP问题有两种解法，复杂度分别为O（n^2）和O（nlogn）。</p>
<p>O(n^2)的算法比较容易理解，就是用dp[i]表示数列到i位置的最长递增（减）子序列的长度。
第一重循环自然就是枚举i的位置，第二重循环就是从0到i-1，选择一个数字比num[i]小（大）的数的dp值加1，看能否更新dp[i]。
以最长递增子序列为例，就是dp[i] = max(dp[j]+1),(j=0..i-1,且num[j] &lt; num[i])。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#57606a">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#cf222e">using</span> <span style="color:#cf222e">namespace</span> std<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">int</span> n<span style="color:#1f2328">,</span>k<span style="color:#1f2328">,</span>c<span style="color:#1f2328">,</span>ans<span style="color:#1f2328">[</span><span style="color:#0550ae">1100</span><span style="color:#1f2328">],</span>maxx<span style="color:#1f2328">,</span>i<span style="color:#1f2328">,</span>j<span style="color:#1f2328">,</span>data<span style="color:#1f2328">[</span><span style="color:#0550ae">1100</span><span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">int</span> <span style="color:#6639ba">main</span><span style="color:#1f2328">(){</span>
</span></span><span style="display:flex;"><span>	cin<span style="color:#0550ae">&gt;&gt;</span>n<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span>i<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span>n<span style="color:#1f2328">;</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">)</span>cin<span style="color:#0550ae">&gt;&gt;</span>data<span style="color:#1f2328">[</span>i<span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span>	ans<span style="color:#1f2328">[</span><span style="color:#0550ae">0</span><span style="color:#1f2328">]</span><span style="color:#0550ae">=</span><span style="color:#0550ae">1</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span>i<span style="color:#0550ae">=</span><span style="color:#0550ae">1</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span>n<span style="color:#1f2328">;</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>		ans<span style="color:#1f2328">[</span>i<span style="color:#1f2328">]</span><span style="color:#0550ae">=</span><span style="color:#0550ae">1</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span>j<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>j<span style="color:#0550ae">&lt;</span>i<span style="color:#1f2328">;</span>j<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>			<span style="color:#cf222e">if</span><span style="color:#1f2328">(</span>data<span style="color:#1f2328">[</span>j<span style="color:#1f2328">]</span><span style="color:#0550ae">&lt;</span>data<span style="color:#1f2328">[</span>i<span style="color:#1f2328">]</span> <span style="color:#0550ae">&amp;&amp;</span> ans<span style="color:#1f2328">[</span>j<span style="color:#1f2328">]</span><span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#0550ae">&gt;</span>ans<span style="color:#1f2328">[</span>i<span style="color:#1f2328">])</span>
</span></span><span style="display:flex;"><span>				ans<span style="color:#1f2328">[</span>i<span style="color:#1f2328">]</span> <span style="color:#0550ae">=</span> ans<span style="color:#1f2328">[</span>j<span style="color:#1f2328">]</span> <span style="color:#0550ae">+</span> <span style="color:#0550ae">1</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>	maxx<span style="color:#0550ae">=</span><span style="color:#0550ae">1</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span>i<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span>n<span style="color:#1f2328">;</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">)</span><span style="color:#cf222e">if</span><span style="color:#1f2328">(</span>ans<span style="color:#1f2328">[</span>i<span style="color:#1f2328">]</span><span style="color:#0550ae">&gt;</span>maxx<span style="color:#1f2328">)</span>maxx<span style="color:#0550ae">=</span>ans<span style="color:#1f2328">[</span>i<span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span>	cout<span style="color:#0550ae">&lt;&lt;</span>maxx<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span></code></pre></div><p>O（nlogn）的算法其实就是针对O（n^2）算法中的第二重循环进行优化，还是以最长递增子序列为例，我们维护一个待选序列ls，这个序列满足ls[i]中存放的就是最长递增子序列为长度i的数列中最大的一个元素。换句话说，到最后，ls数组有多长，最长递增子序列就有多长。
然后我们会发现，ls数组本身就是一组符合条件的最长递增子序列的解，里面的数本身就是有序的，然后更新的时候，我们就可以用到二分查找来进行优化了。
一开始的时候，ls数组长度为0，数字自动填充到ls数组中的第一个位置，长度变为1，然后后面每来一个数，都用二分搜索，找到ls数组中比当前插入值大的最小一个数的位置，然后替换它，如果找不到（即当前要插入的值是最大的），自然就是添加到ls数组末尾，使数组长度增加。
因为我是按照原始数组的顺序进行DP的，那么我当前要插入的值要找到在最终答案里的位置，由于是最长递增序列，那么我前面的数一定比我小，所以我插入的位置一定就是恰好所有前面的数都比我小的位置，替换掉的就是跟我有相同递增长度的那个值，但是我比那个数小，更有前途与后面的数构成更长的递增子序列。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>////二分查找优化 nlogn
</span></span><span style="display:flex;"><span>#include&lt;stdio.h&gt;
</span></span><span style="display:flex;"><span>#include&lt;string.h&gt;
</span></span><span style="display:flex;"><span>#include&lt;math.h&gt;
</span></span><span style="display:flex;"><span>#define MAX 1005
</span></span><span style="display:flex;"><span>int f[MAX];
</span></span><span style="display:flex;"><span>int i,j,ans,n;
</span></span><span style="display:flex;"><span>int left,right,x,mid;
</span></span><span style="display:flex;"><span>int main(){
</span></span><span style="display:flex;"><span>    scanf(&#34;%d&#34;,&amp;n);
</span></span><span style="display:flex;"><span>    ans=0;
</span></span><span style="display:flex;"><span>    for (i=1; i&lt;=n ; i++){
</span></span><span style="display:flex;"><span>        scanf(&#34;%d&#34;,&amp;x);
</span></span><span style="display:flex;"><span>        left=1;
</span></span><span style="display:flex;"><span>        right=ans;
</span></span><span style="display:flex;"><span>        while (left&lt;right){
</span></span><span style="display:flex;"><span>            mid=(left+right)/2;
</span></span><span style="display:flex;"><span>            if (f[mid]&lt;x) left=mid+1;
</span></span><span style="display:flex;"><span>            else right=mid;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        if (left&gt;=right&amp;&amp;x&gt;f[ans]||ans==0){
</span></span><span style="display:flex;"><span>            ans++;
</span></span><span style="display:flex;"><span>            f[ans]=x;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        else if (x&lt;f[left]){
</span></span><span style="display:flex;"><span>            f[left]=x;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    printf(&#34;%d\n&#34;,ans);
</span></span><span style="display:flex;"><span>    return 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>2、最长公共子序列：求两个字符串的最长公共子序列的长度。 <a href="http://poj.org/problem?id=1458">poj1458</a></p>
<p>这个dp的算法也很经典，在算法导论上有详细的描述。
我们构建一个二维数组dp[N][N],dp[i][j]用来表示串A的第i位为止和串B到第j位为止所拥有的最长公共子序列的长度。
如果stra[i]和strb[j]相等的话，那么显然dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1)，否则就是从dp[i][j-1]和dp[i-1][j]中取个较大的值。（从dp[i-1][j-1]递推过来的情况已经包含在dp[i][j-1]和dp[i-1][j]里面了。）</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#57606a">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#cf222e">using</span> <span style="color:#cf222e">namespace</span> std<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">char</span> a<span style="color:#1f2328">[</span><span style="color:#0550ae">300</span><span style="color:#1f2328">],</span>b<span style="color:#1f2328">[</span><span style="color:#0550ae">300</span><span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">int</span> c<span style="color:#1f2328">[</span><span style="color:#0550ae">300</span><span style="color:#1f2328">][</span><span style="color:#0550ae">300</span><span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">int</span> <span style="color:#6639ba">lcs_length</span><span style="color:#1f2328">()</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">int</span> cnt<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">int</span> m<span style="color:#0550ae">=</span>strlen<span style="color:#1f2328">(</span>a<span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">int</span> n<span style="color:#0550ae">=</span>strlen<span style="color:#1f2328">(</span>b<span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">int</span> i<span style="color:#1f2328">,</span>j<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span>i<span style="color:#0550ae">=</span><span style="color:#0550ae">1</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span>m<span style="color:#1f2328">;</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">)</span>c<span style="color:#1f2328">[</span>i<span style="color:#1f2328">][</span><span style="color:#0550ae">0</span><span style="color:#1f2328">]</span><span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span>j<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>j<span style="color:#0550ae">&lt;</span>n<span style="color:#1f2328">;</span>j<span style="color:#0550ae">++</span><span style="color:#1f2328">)</span>c<span style="color:#1f2328">[</span><span style="color:#0550ae">0</span><span style="color:#1f2328">][</span>j<span style="color:#1f2328">]</span><span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span>i<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span>m<span style="color:#1f2328">;</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>		<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span>j<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>j<span style="color:#0550ae">&lt;</span>n<span style="color:#1f2328">;</span>j<span style="color:#0550ae">++</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>			<span style="color:#cf222e">if</span><span style="color:#1f2328">(</span>a<span style="color:#1f2328">[</span>i<span style="color:#1f2328">]</span><span style="color:#0550ae">==</span>b<span style="color:#1f2328">[</span>j<span style="color:#1f2328">])</span>c<span style="color:#1f2328">[</span>i<span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#1f2328">][</span>j<span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#1f2328">]</span><span style="color:#0550ae">=</span>c<span style="color:#1f2328">[</span>i<span style="color:#1f2328">][</span>j<span style="color:#1f2328">]</span><span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>			<span style="color:#cf222e">else</span> <span style="color:#cf222e">if</span><span style="color:#1f2328">(</span>c<span style="color:#1f2328">[</span>i<span style="color:#1f2328">][</span>j<span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#1f2328">]</span><span style="color:#0550ae">&gt;=</span>c<span style="color:#1f2328">[</span>i<span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#1f2328">][</span>j<span style="color:#1f2328">])</span>
</span></span><span style="display:flex;"><span>				c<span style="color:#1f2328">[</span>i<span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#1f2328">][</span>j<span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#1f2328">]</span><span style="color:#0550ae">=</span>c<span style="color:#1f2328">[</span>i<span style="color:#1f2328">][</span>j<span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span>			<span style="color:#cf222e">else</span> c<span style="color:#1f2328">[</span>i<span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#1f2328">][</span>j<span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#1f2328">]</span><span style="color:#0550ae">=</span>c<span style="color:#1f2328">[</span>i<span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#1f2328">][</span>j<span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#cf222e">return</span> c<span style="color:#1f2328">[</span>m<span style="color:#1f2328">][</span>n<span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">int</span> <span style="color:#6639ba">main</span><span style="color:#1f2328">()</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">while</span><span style="color:#1f2328">(</span>scanf<span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;%s%s&#34;</span><span style="color:#1f2328">,</span>a<span style="color:#1f2328">,</span>b<span style="color:#1f2328">)</span><span style="color:#0550ae">!=</span>EOF<span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>		printf<span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;%d</span><span style="color:#0a3069">\n</span><span style="color:#0a3069">&#34;</span><span style="color:#1f2328">,</span>lcs_length<span style="color:#1f2328">());</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span></code></pre></div><p>3、最大子段和：从一个有N个浮点数的一维数组中找出一段连续的元素，使其构成的子数组之和最大。
这个题也许算不上一个标准的动态规划经典题目，但是在《编程珠玑》和《编程之美》两本书上，均有大篇幅的笔墨讲解，所以我认为它是有价值的。
O（n^2）的暴力解法大家应该都很容易想到，我就不说了。
然后我们自然要想着优化，那么分治的思想就可以让我们联想到O（nlogn）的算法。
(A[0],..,A[n-1])的最大子段和无非包含在3种情况内，由数组的左半部分组成，由数组的右半部分组成，横跨数组左右两边。
对于前两种情况，就是递归解决。对于第三种情况，因为它一定包含A数组最中间，即A[n/2-1]这个数,那么我们只要从这个数向左右两边伸展开去，找个最大值即可。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>float maxsum(float *A,int l,int r){
</span></span><span style="display:flex;"><span>	if(l&gt;r)return 0;
</span></span><span style="display:flex;"><span>	if(l==r)return max(0,A[l]);
</span></span><span style="display:flex;"><span>	int mid = (l+r)/2;
</span></span><span style="display:flex;"><span>	double sum;
</span></span><span style="display:flex;"><span>	double lmax = sum = 0;
</span></span><span style="display:flex;"><span>	for(int i=mid;i&gt;=l;i--){
</span></span><span style="display:flex;"><span>		sum+=A[i];
</span></span><span style="display:flex;"><span>		lmax = max(lmax,sum);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	double rmax = sum = 0;
</span></span><span style="display:flex;"><span>	for(int i=mid+1;i&lt;=r;i++){
</span></span><span style="display:flex;"><span>		sum+=A[i];
</span></span><span style="display:flex;"><span>		rmax = max(rmax,sum);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	return max(lmax+rmax,maxsum(l,mid),maxsum(mid+1,r));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际上还有O（N）的算法，而它也是最简单，只要扫一遍数组即可。从左向右，计算当前的和，如果当前的和一直是正的，那么不管是大是小，我后面的最大字段和加上当前这一段非负的，也没有亏，还是最大字段和。如果当前的和出现了负值，那么当前值就置为0。肯定是不要了啊，最次我什么都不选，也是0.就这样一路扫到最后即可。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>float maxsum(float *A,int n){
</span></span><span style="display:flex;"><span>	double nstart = A[n-1];
</span></span><span style="display:flex;"><span>	double nall = A[n-1];
</span></span><span style="display:flex;"><span>	for(int i=n-2;i&gt;=0;i--){
</span></span><span style="display:flex;"><span>		if(nstart&lt;0)nstart = 0;
</span></span><span style="display:flex;"><span>		nstart+=A[i];
</span></span><span style="display:flex;"><span>		if(nstart&gt;nall)
</span></span><span style="display:flex;"><span>			nall = nstart;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	return nall;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>4、背包问题：这个看一下<a href="https://wonderflow.info/images/2012-08-08-e587a0e7a78de7ae80e58d95e7b1bbe59e8be79a84dp/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2.pdf">背包九讲</a>吧。</p>
<p><strong>树形动态规划</strong>
5、<a href="http://poj.org/problem?id=1463">POJ 1463</a> 有若干结点，结点之间有路相连，构成树形结构，如果在一个结点上放置一个士兵，与这个结点相连的路就可以被监视，现在要监视所有的路，问至少要多少士兵。</p>
<p>这个是最简单的树形DP，可以理解为DFS遍历整棵树的同时，记录下我当前点放士兵和不放士兵所能达到的最优情况。因为如果我树确定了根节点，子树一个个下去是不存在后效性的问题的，而且子树本身就是一个子结构，所以很容易联想到DP来解决这一类问题。
开个DP[N][2]的数组，dp[i][0]表示，以i节点为子树的根，i节点不放士兵，最少总共要放多少士兵。dp[i][1]就是i节点放士兵最少要在子树中放多少士兵。
显然如果一个子树的根节点不放士兵的话，那么与其相连的所有子树的根节点一定要放士兵，否则那条边就没有士兵看管了。
反之，如果一个子树的根节点放士兵的话，那么与其相连的所有子树可以选择放士兵，或者不放士兵。
理解了这个，记忆化的过程，或者说状态转移的过程就一目了然了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#57606a">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">#include&lt;cstdio&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">#include&lt;cstring&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">#include&lt;vector&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#cf222e">using</span> <span style="color:#cf222e">namespace</span> std<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>vector<span style="color:#0550ae">&lt;</span><span style="color:#cf222e">int</span><span style="color:#0550ae">&gt;</span>edge<span style="color:#1f2328">[</span><span style="color:#0550ae">1510</span><span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">int</span> dp<span style="color:#1f2328">[</span><span style="color:#0550ae">1510</span><span style="color:#1f2328">][</span><span style="color:#0550ae">2</span><span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">bool</span> vis<span style="color:#1f2328">[</span><span style="color:#0550ae">1510</span><span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">int</span> <span style="color:#6639ba">dfs</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> ind<span style="color:#1f2328">,</span><span style="color:#cf222e">int</span> status<span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">if</span><span style="color:#1f2328">(</span>dp<span style="color:#1f2328">[</span>ind<span style="color:#1f2328">][</span>status<span style="color:#1f2328">]</span><span style="color:#0550ae">!=-</span><span style="color:#0550ae">1</span><span style="color:#1f2328">)</span><span style="color:#cf222e">return</span> dp<span style="color:#1f2328">[</span>ind<span style="color:#1f2328">][</span>status<span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span>	vis<span style="color:#1f2328">[</span>ind<span style="color:#1f2328">]</span> <span style="color:#0550ae">=</span> <span style="color:#6639ba">true</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>	dp<span style="color:#1f2328">[</span>ind<span style="color:#1f2328">][</span><span style="color:#0550ae">0</span><span style="color:#1f2328">]</span> <span style="color:#0550ae">=</span> <span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>	dp<span style="color:#1f2328">[</span>ind<span style="color:#1f2328">][</span><span style="color:#0550ae">1</span><span style="color:#1f2328">]</span> <span style="color:#0550ae">=</span> <span style="color:#0550ae">1</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> i<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span>edge<span style="color:#1f2328">[</span>ind<span style="color:#1f2328">].</span>size<span style="color:#1f2328">();</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>		<span style="color:#cf222e">int</span> v <span style="color:#0550ae">=</span> edge<span style="color:#1f2328">[</span>ind<span style="color:#1f2328">][</span>i<span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span>		<span style="color:#cf222e">if</span><span style="color:#1f2328">(</span>vis<span style="color:#1f2328">[</span>v<span style="color:#1f2328">])</span><span style="color:#cf222e">continue</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>		dp<span style="color:#1f2328">[</span>ind<span style="color:#1f2328">][</span><span style="color:#0550ae">0</span><span style="color:#1f2328">]</span> <span style="color:#0550ae">+=</span> dfs<span style="color:#1f2328">(</span>v<span style="color:#1f2328">,</span><span style="color:#0550ae">1</span><span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>		dp<span style="color:#1f2328">[</span>ind<span style="color:#1f2328">][</span><span style="color:#0550ae">1</span><span style="color:#1f2328">]</span> <span style="color:#0550ae">+=</span> min<span style="color:#1f2328">(</span>dfs<span style="color:#1f2328">(</span>v<span style="color:#1f2328">,</span><span style="color:#0550ae">1</span><span style="color:#1f2328">),</span>dfs<span style="color:#1f2328">(</span>v<span style="color:#1f2328">,</span><span style="color:#0550ae">0</span><span style="color:#1f2328">));</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">return</span> dp<span style="color:#1f2328">[</span>ind<span style="color:#1f2328">][</span>status<span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">int</span> <span style="color:#6639ba">main</span><span style="color:#1f2328">(){</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">int</span> ind<span style="color:#1f2328">,</span>num<span style="color:#1f2328">,</span>t<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">int</span> n<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">while</span><span style="color:#1f2328">(</span>scanf<span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;%d&#34;</span><span style="color:#1f2328">,</span><span style="color:#0550ae">&amp;</span>n<span style="color:#1f2328">)</span><span style="color:#0550ae">!=</span>EOF<span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>		<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> i<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;=</span>n<span style="color:#1f2328">;</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">)</span>edge<span style="color:#1f2328">[</span>i<span style="color:#1f2328">].</span>clear<span style="color:#1f2328">();</span>
</span></span><span style="display:flex;"><span>		<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> i<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span>n<span style="color:#1f2328">;</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>			scanf<span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;%d:(%d)&#34;</span><span style="color:#1f2328">,</span><span style="color:#0550ae">&amp;</span>ind<span style="color:#1f2328">,</span><span style="color:#0550ae">&amp;</span>num<span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>			<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> j<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>j<span style="color:#0550ae">&lt;</span>num<span style="color:#1f2328">;</span>j<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>				scanf<span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;%d&#34;</span><span style="color:#1f2328">,</span><span style="color:#0550ae">&amp;</span>t<span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>				edge<span style="color:#1f2328">[</span>ind<span style="color:#1f2328">].</span>push_back<span style="color:#1f2328">(</span>t<span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>				edge<span style="color:#1f2328">[</span>t<span style="color:#1f2328">].</span>push_back<span style="color:#1f2328">(</span>ind<span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>			<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>		memset<span style="color:#1f2328">(</span>dp<span style="color:#1f2328">,</span><span style="color:#0550ae">-</span><span style="color:#0550ae">1</span><span style="color:#1f2328">,</span><span style="color:#cf222e">sizeof</span><span style="color:#1f2328">(</span>dp<span style="color:#1f2328">));</span>
</span></span><span style="display:flex;"><span>		memset<span style="color:#1f2328">(</span>vis<span style="color:#1f2328">,</span><span style="color:#0550ae">0</span><span style="color:#1f2328">,</span><span style="color:#cf222e">sizeof</span><span style="color:#1f2328">(</span>vis<span style="color:#1f2328">));</span>
</span></span><span style="display:flex;"><span>		dfs<span style="color:#1f2328">(</span><span style="color:#0550ae">0</span><span style="color:#1f2328">,</span><span style="color:#0550ae">1</span><span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>		printf<span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;%d</span><span style="color:#0a3069">\n</span><span style="color:#0a3069">&#34;</span><span style="color:#1f2328">,</span>min<span style="color:#1f2328">(</span>dp<span style="color:#1f2328">[</span><span style="color:#0550ae">0</span><span style="color:#1f2328">][</span><span style="color:#0550ae">0</span><span style="color:#1f2328">],</span>dp<span style="color:#1f2328">[</span><span style="color:#0550ae">0</span><span style="color:#1f2328">][</span><span style="color:#0550ae">1</span><span style="color:#1f2328">]));</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">return</span> <span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span></code></pre></div><p><strong>概率动态规划</strong></p>
<p>6、<a href="http://poj.org/problem?id=3071">poj3071</a> 一场足球淘汰赛有2ˆn 支队伍参加，编号为1,2,.,2^n，按队伍编号进行比赛，每轮比赛的胜者再与对应比赛的胜者进行比赛，输掉一场比赛该队伍即被淘汰。现在给出每支队伍与其他所有队伍进行比赛胜利的概率，求最可能成为冠军的队伍编号。POJ上与其基本相同的题：<a href="http://poj.org/problem?id=2261">POJ2261</a>
阿森说，概率DP根本不是DP，因为涉及到了概率，根本不存在最优的情况。我深以为然。
就是按公式算起来嘛！用到DP的地方估计也就是算的过程，一步步递推很像DP的写法而已。
那么这题其实也是这样的，按照1号先和2号打，3号先和4号打.. 然后第二轮，1号和3、4中的胜者打（由于是概率，所以3、4都有可能胜，所以就是和3、4都计算），以此类推。
那么为什么要把这个题目放在这里呢？
价值就在于中间计算的过程。我们可以想象一下，其实淘汰赛的比赛过程就是一颗满二叉树，而满二叉树有这样一个性质，父亲节点相同的两个左右子树，其序号映射到二进制位上比较的话，他们只相差1位。第n轮比赛其实就是子树向上去的第n层，然后我要取的就是该层的兄弟节点子树包含的所有最底层的节点。怎么找到这些点呢？操作很简单，2^n~2^(n+1)之间所有的点与当前点异或一下，就出来啦。（实际上就是自底向上第n层那个点相反的变化了一下而已。）</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#57606a">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">#include&lt;cstdio&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">#include&lt;cstring&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">#include&lt;vector&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#cf222e">using</span> <span style="color:#cf222e">namespace</span> std<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">double</span> dp<span style="color:#1f2328">[</span><span style="color:#0550ae">16</span><span style="color:#1f2328">][</span><span style="color:#0550ae">512</span><span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">double</span> m<span style="color:#1f2328">[</span><span style="color:#0550ae">512</span><span style="color:#1f2328">][</span><span style="color:#0550ae">512</span><span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">int</span> len<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">int</span> <span style="color:#6639ba">main</span><span style="color:#1f2328">(){</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">int</span> n<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">while</span><span style="color:#1f2328">(</span>scanf<span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;%d&#34;</span><span style="color:#1f2328">,</span><span style="color:#0550ae">&amp;</span>n<span style="color:#1f2328">)</span><span style="color:#0550ae">&amp;&amp;</span>n<span style="color:#0550ae">!=-</span><span style="color:#0550ae">1</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>		len <span style="color:#0550ae">=</span> <span style="color:#1f2328">(</span><span style="color:#0550ae">1</span><span style="color:#0550ae">&lt;&lt;</span>n<span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> i<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span>len<span style="color:#1f2328">;</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>			<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> j<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>j<span style="color:#0550ae">&lt;</span>len<span style="color:#1f2328">;</span>j<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>				scanf<span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;%lf&#34;</span><span style="color:#1f2328">,</span><span style="color:#0550ae">&amp;</span>m<span style="color:#1f2328">[</span>i<span style="color:#1f2328">][</span>j<span style="color:#1f2328">]);</span>
</span></span><span style="display:flex;"><span>			<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>			dp<span style="color:#1f2328">[</span><span style="color:#0550ae">0</span><span style="color:#1f2328">][</span>i<span style="color:#1f2328">]</span> <span style="color:#0550ae">=</span> <span style="color:#0550ae">1</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> k<span style="color:#0550ae">=</span><span style="color:#0550ae">1</span><span style="color:#1f2328">;</span>k<span style="color:#0550ae">&lt;=</span>n<span style="color:#1f2328">;</span>k<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>			<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> i<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span>len<span style="color:#1f2328">;</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>				<span style="color:#cf222e">double</span> sum <span style="color:#0550ae">=</span> <span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>				<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> j<span style="color:#0550ae">=</span><span style="color:#1f2328">(</span><span style="color:#0550ae">1</span><span style="color:#0550ae">&lt;&lt;</span><span style="color:#1f2328">(</span>k<span style="color:#0550ae">-</span><span style="color:#0550ae">1</span><span style="color:#1f2328">));</span>j<span style="color:#0550ae">&lt;</span><span style="color:#1f2328">(</span><span style="color:#0550ae">1</span><span style="color:#0550ae">&lt;&lt;</span>k<span style="color:#1f2328">);</span>j<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>					sum <span style="color:#0550ae">+=</span> dp<span style="color:#1f2328">[</span>k<span style="color:#0550ae">-</span><span style="color:#0550ae">1</span><span style="color:#1f2328">][</span>j<span style="color:#0550ae">^</span>i<span style="color:#1f2328">]</span><span style="color:#0550ae">*</span>m<span style="color:#1f2328">[</span>i<span style="color:#1f2328">][</span>j<span style="color:#0550ae">^</span>i<span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span>				<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>				dp<span style="color:#1f2328">[</span>k<span style="color:#1f2328">][</span>i<span style="color:#1f2328">]</span> <span style="color:#0550ae">=</span> dp<span style="color:#1f2328">[</span>k<span style="color:#0550ae">-</span><span style="color:#0550ae">1</span><span style="color:#1f2328">][</span>i<span style="color:#1f2328">]</span><span style="color:#0550ae">*</span>sum<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>			<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#cf222e">int</span> ans <span style="color:#0550ae">=</span> <span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> i<span style="color:#0550ae">=</span><span style="color:#0550ae">1</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span>len<span style="color:#1f2328">;</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>			<span style="color:#cf222e">if</span><span style="color:#1f2328">(</span>dp<span style="color:#1f2328">[</span>n<span style="color:#1f2328">][</span>i<span style="color:#1f2328">]</span><span style="color:#0550ae">&gt;</span>dp<span style="color:#1f2328">[</span>n<span style="color:#1f2328">][</span>ans<span style="color:#1f2328">]){</span>
</span></span><span style="display:flex;"><span>				ans <span style="color:#0550ae">=</span> i<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>			<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>		printf<span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;%d</span><span style="color:#0a3069">\n</span><span style="color:#0a3069">&#34;</span><span style="color:#1f2328">,</span>ans<span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span></code></pre></div><p><strong>状态压缩动态规划</strong></p>
<p>7、这类题目的基本思想就是拿一个数的每个或每两个二进制位表示当前位的状态，然后进行状态转移。我博客上之前写过几个这样题目的解题报告，这里就暂不添加其他题目了。我先前的解题报告：<a href="http://wonderflow.info/archives/267">ZOJ1100 Mondriaan’s Dream</a> <a href="http://wonderflow.info/archives/348">ZOJ1155 《Triangle War》</a> <a href="http://wonderflow.info/archives/336">hdu4317《Unfair Nim》</a></p>
<p><strong>插头动态规划</strong></p>
<p>8、这一类的DP其实是以状态压缩DP为基础的，在状态压缩的基础上假设出更多不同的状态（不同的插头），然后进行转移。
国家队2008年陈丹琦的论文《基于连通性状态压缩的动态规划问题》，非常详细的介绍了这一类的DP，大家可以百度或者google搜一下这篇文章。
然后集训队讲报告的时候，关于这一块，我觉得方老师讲解的非常好，在此设立<a href="http://fjy.me/hdu-1693.html">传送门</a>，有兴趣的话可以去读一下方老师的文章，图文并茂很清楚~</p>
<p>几类简单的DP类型大致就是这样了吧，其实DP千变万化，最主要的还是要看出问题的子结构，想清楚里面的状态转移，以及想清楚如何优化。</p>

    </div>
  </article>
</div>

    </main>
    <footer class="bg-near-white bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
    <a class="f4 fw4 hover-black no-underline mid-gray dn dib-ns pv2 ph3" href="https://wonderflow.info/">
      &copy;  奇迹之流WonderfloW 2025 
    </a>
    <div><div class="ananke-socials"></div>
</div>
    <a href="https://beian.miit.gov.cn/" class="link db f6 pa2 br3 bg-mid-gray white dim w4 tc"> 沪ICP备2020029591号 </a>
    
  </div>
</footer>


<div class="reading-progress" id="reading-progress"></div>


<button class="back-to-top" id="back-to-top" aria-label="Back to top">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <polyline points="18 15 12 9 6 15"></polyline>
  </svg>
</button>


<script>
(function() {
  
  const progressBar = document.getElementById('reading-progress');
  const backToTop = document.getElementById('back-to-top');

  function updateProgress() {
    const scrollTop = window.scrollY;
    const docHeight = document.documentElement.scrollHeight - window.innerHeight;
    const progress = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;

    if (progressBar) {
      progressBar.style.width = progress + '%';
    }

    
    if (backToTop) {
      if (scrollTop > 300) {
        backToTop.classList.add('visible');
      } else {
        backToTop.classList.remove('visible');
      }
    }
  }

  
  let ticking = false;
  window.addEventListener('scroll', function() {
    if (!ticking) {
      window.requestAnimationFrame(function() {
        updateProgress();
        ticking = false;
      });
      ticking = true;
    }
  });

  
  if (backToTop) {
    backToTop.addEventListener('click', function() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });
  }

  
  updateProgress();
})();
</script>

  </body>
</html>
