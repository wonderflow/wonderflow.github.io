<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>STL Containers 之 vector | 奇迹之流WonderfloW</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="我觉得，vector是STL中最常用的容器，没有之一。
因为它简单，安全，也容易理解。实际上它就是一个刚学C&#43;&#43;时我们梦寐以求的动态数组，大小不需要一开始的时候定，而又不像链表操作起来那么麻烦。
先说一下最简单的几个用法吧：
比如说你要创建一个一维数组，数组元素是一个结构体。（为什么用结构体？因为结构体都会了的话，int之类的，就简单了。）
在示例代码中用注释的方式讲解一下各种vector函数的用法。

# include 
# include 

using namespace std;


struct Node{
int x,y;
Node(){x = 30;}
Node(int x,int y):x(x),y(y){}//构造函数
};





int main(){
vectormyvector;   //定义一个vector数组
for(int i=0;i&lt;9;i&#43;&#43;){
myvector.push_back(Node(i,1&#43;i));    //插入一个元素
}
myvector.pop_back();//与之对应的pop_back是从末尾踢掉一个元素





cout&lt;&lt;&#34;first out:&#34;;
for(int i=0;i&lt;myvector.size();i&#43;&#43;){ //vector元素的遍历，几乎跟平时数组一样的写法
cout&lt;&lt;&#34; &#34;&lt;&lt;myvector[i].x;   //vector元素的输出
}
cout&lt;&lt;endl;





//说一下迭代器，迭代器可以理解为指针，目的是为了迭代容器中的元素
//迭代器的定义跟我们声明的容器类型是相同的，在这里是
vector::iterator it;
it = myvector.begin()&#43;3;    //begin()就是开始的位置，加几就是指向了数组中的第几个





myvector.erase(it); //删除数组第一个元素
//erase函数就是起到删除的作用，但是参数是迭代器
//也可以成段删除，给的两个参数都是迭代器，分别是成段删除的开头位置和末尾位置
myvector.erase(myvector.begin(),myvector.begin()&#43;3);//这里的加操作符是迭代器元素个数的加
//删除了这么多，我们重新输出看看
//此处我们用的迭代器的方法遍历vector数组
//值得一提的是，如果在遍历的过程中删除，那么vector元素在删除操作的同时
//会把被删除元素后面的元素往前移动，有删除的那次指针不加
cout&lt;&lt;&#34;second out:&#34;;
for(it = myvector.begin();it&lt;myvector.end();it&#43;&#43;){
cout&lt;&lt;&#34; &#34;&lt;x;
}
cout&lt;&lt;endl;





//一次性全部删除如何操作？
myvector.clear();//对，调用一次clear就可以了。





//重新分配给vector一些值，下面我们用到assign函数，分配内容。
const Node a(100,0);
myvector.assign(4,a);//可以直接分配，第一个是次数，第二个参数是数值(元素)
//这样以后，myvector中就是4个{100,0}
vector vt;
//再用迭代器来范围性的赋值，两个参数分别是开始元素和结尾元素
//同时要说明的是，assign函数调用以后，先前的内容会被清除
vt.assign(myvector.begin()&#43;1,myvector.end()-1);
cout&lt;&lt;&#34;third out:&#34;;
for(it = vt.begin();it&lt;vt.end();it&#43;&#43;){
cout&lt;&lt;&#34; &#34;&lt;x;
}
cout&lt;&lt;endl;
Node myints[5];
for(int i=0;i&lt;5;i&#43;&#43;)
myints[i] = Node(i,i&#43;1);
myvector.assign(myints,myints&#43;5);//最后，用数组assign赋值





//反向迭代器，跟迭代器是一样的，就是以数组的末尾为开头，就是定义的方法有所不同
vector::reverse_iterator rit;
//相应的，要从末尾开始，我们要用vector中的rbgin()和rend()函数，意思自然是反向开头和反向末尾
//反向迭代器的用法和迭代器其实是一样的，就是为了统一才出现了rbegin,rend;
cout&lt;&lt;&#34;fourth out:&#34;;
for(rit=myvector.rbegin();rit&lt;myvector.rend();rit&#43;&#43;){
cout&lt;&lt;&#34; &#34;&lt;x;
}
cout&lt;&lt;endl;





//然后我们说一下用下标定位数组的元素,用at函数和用中括号是一样的效果
cout&lt;&lt;&#34;fifth out:&#34;;
cout&lt;&lt;myvector.at(2).x&lt;&lt;&#34; &#34;&lt;&lt;myvector[2].x&lt;&lt;&#34; &#34;;
//front函数和back函数是一对，分别指向数组第一个元素和最后一个元素的值
cout&lt;&lt;myvector.front().x&lt;&lt;&#34; &#34;&lt;&lt;myvector.back().x&lt;&lt;endl;





cout&lt;&lt;&#34;is empty? : &#34;&lt;&lt;myvector.empty()&lt;&lt;endl;//vector是否为空
cout&lt;&lt;&#34;size: &#34;&lt;&lt;myvector.size()&lt;&lt;endl;//vector中的元素个数
//说到size，就顺便说一下resize，resize函数可以重新改变vector的大小
myvector.resize(3);
//这个就把size变成了3，如果原来的大小超过了3，就把超过的地方删去，
//如果原来不足3，就自动调用缺省构造函数
myvector.resize(6,Node(1,1));
//这个就是把大小变成6，原本有的不动，扩展出来的用（0,0）填
myvector.resize(10);





cout&lt;&lt;&#34;sixth out:&#34;;
for(int i=0;i&lt;myvector.size();i&#43;&#43;){
cout&lt;&lt;&#34; &#34;&lt;&lt;myvector[i].x;
}
cout&lt;&lt;endl;





//最后说一下swap
//vector这里的swap和algorithm里面的swap是大不一样的，
//这里的swap是交换两个vector容器
vt.swap(myvector);//进行了这步以后，vt就和myvector交换了
cout&lt;&lt;&#34;seventh out:&#34;;
for(int i=0;i&lt;myvector.size();i&#43;&#43;){
cout&lt;&lt;&#34; &#34;&lt;&lt;myvector[i].x;
}
cout&lt;&lt;endl;





//另外还有一种添加元素的方法是insert，但是不常用，这里就不介绍了
//还有一些其他的非常不常用，我就不介绍了。





}
/*
输出：
first out: 0 1 2 3 4 5 6 7
second out: 4 5 6 7
third out: 100 100
fourth out: 4 3 2 1 0
fifth out:2 2 0 4
is empty? : 0
size: 5
sixth out: 0 1 2 1 1 1 30 30 30 30
seventh out: 100 100
*/
基本上我平时常用的我均已经在代码中提到了，其实vector本身独立使用并不多见，更多的是vector跟其他stl库结合使用，尤其是algorithm库里的泛型算法。">
    <meta name="generator" content="Hugo 0.153.4">
    
    
    
      <meta name="robots" content="index, follow">
    
    <meta name="author" content="admin">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.efe4d852f731d5d1fbb87718387202a97aafd768cdcdaed0662bbe6982e91824.css" >



  
    <link rel="stylesheet" href="/css/custom.css">
  


    


    
      
<link rel="shortcut icon" href="/favicon_io/favicon.ico" type="image/x-icon" />


    

    

    
      <link rel="canonical" href="https://wonderflow.info/posts/2012/08/10/stl-containers-e4b98b-vector/">
    

    
    
    <meta property="og:url" content="https://wonderflow.info/posts/2012/08/10/stl-containers-e4b98b-vector/">
  <meta property="og:site_name" content="奇迹之流WonderfloW">
  <meta property="og:title" content="STL Containers 之 vector">
  <meta property="og:description" content="我觉得，vector是STL中最常用的容器，没有之一。
因为它简单，安全，也容易理解。实际上它就是一个刚学C&#43;&#43;时我们梦寐以求的动态数组，大小不需要一开始的时候定，而又不像链表操作起来那么麻烦。
先说一下最简单的几个用法吧：
比如说你要创建一个一维数组，数组元素是一个结构体。（为什么用结构体？因为结构体都会了的话，int之类的，就简单了。）
在示例代码中用注释的方式讲解一下各种vector函数的用法。
# include # include using namespace std; struct Node{ int x,y; Node(){x = 30;} Node(int x,int y):x(x),y(y){}//构造函数 }; int main(){ vectormyvector; //定义一个vector数组 for(int i=0;i&lt;9;i&#43;&#43;){ myvector.push_back(Node(i,1&#43;i)); //插入一个元素 } myvector.pop_back();//与之对应的pop_back是从末尾踢掉一个元素 cout&lt;&lt;&#34;first out:&#34;; for(int i=0;i&lt;myvector.size();i&#43;&#43;){ //vector元素的遍历，几乎跟平时数组一样的写法 cout&lt;&lt;&#34; &#34;&lt;&lt;myvector[i].x; //vector元素的输出 } cout&lt;&lt;endl; //说一下迭代器，迭代器可以理解为指针，目的是为了迭代容器中的元素 //迭代器的定义跟我们声明的容器类型是相同的，在这里是 vector::iterator it; it = myvector.begin()&#43;3; //begin()就是开始的位置，加几就是指向了数组中的第几个 myvector.erase(it); //删除数组第一个元素 //erase函数就是起到删除的作用，但是参数是迭代器 //也可以成段删除，给的两个参数都是迭代器，分别是成段删除的开头位置和末尾位置 myvector.erase(myvector.begin(),myvector.begin()&#43;3);//这里的加操作符是迭代器元素个数的加 //删除了这么多，我们重新输出看看 //此处我们用的迭代器的方法遍历vector数组 //值得一提的是，如果在遍历的过程中删除，那么vector元素在删除操作的同时 //会把被删除元素后面的元素往前移动，有删除的那次指针不加 cout&lt;&lt;&#34;second out:&#34;; for(it = myvector.begin();it&lt;myvector.end();it&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;x; } cout&lt;&lt;endl; //一次性全部删除如何操作？ myvector.clear();//对，调用一次clear就可以了。 //重新分配给vector一些值，下面我们用到assign函数，分配内容。 const Node a(100,0); myvector.assign(4,a);//可以直接分配，第一个是次数，第二个参数是数值(元素) //这样以后，myvector中就是4个{100,0} vector vt; //再用迭代器来范围性的赋值，两个参数分别是开始元素和结尾元素 //同时要说明的是，assign函数调用以后，先前的内容会被清除 vt.assign(myvector.begin()&#43;1,myvector.end()-1); cout&lt;&lt;&#34;third out:&#34;; for(it = vt.begin();it&lt;vt.end();it&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;x; } cout&lt;&lt;endl; Node myints[5]; for(int i=0;i&lt;5;i&#43;&#43;) myints[i] = Node(i,i&#43;1); myvector.assign(myints,myints&#43;5);//最后，用数组assign赋值 //反向迭代器，跟迭代器是一样的，就是以数组的末尾为开头，就是定义的方法有所不同 vector::reverse_iterator rit; //相应的，要从末尾开始，我们要用vector中的rbgin()和rend()函数，意思自然是反向开头和反向末尾 //反向迭代器的用法和迭代器其实是一样的，就是为了统一才出现了rbegin,rend; cout&lt;&lt;&#34;fourth out:&#34;; for(rit=myvector.rbegin();rit&lt;myvector.rend();rit&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;x; } cout&lt;&lt;endl; //然后我们说一下用下标定位数组的元素,用at函数和用中括号是一样的效果 cout&lt;&lt;&#34;fifth out:&#34;; cout&lt;&lt;myvector.at(2).x&lt;&lt;&#34; &#34;&lt;&lt;myvector[2].x&lt;&lt;&#34; &#34;; //front函数和back函数是一对，分别指向数组第一个元素和最后一个元素的值 cout&lt;&lt;myvector.front().x&lt;&lt;&#34; &#34;&lt;&lt;myvector.back().x&lt;&lt;endl; cout&lt;&lt;&#34;is empty? : &#34;&lt;&lt;myvector.empty()&lt;&lt;endl;//vector是否为空 cout&lt;&lt;&#34;size: &#34;&lt;&lt;myvector.size()&lt;&lt;endl;//vector中的元素个数 //说到size，就顺便说一下resize，resize函数可以重新改变vector的大小 myvector.resize(3); //这个就把size变成了3，如果原来的大小超过了3，就把超过的地方删去， //如果原来不足3，就自动调用缺省构造函数 myvector.resize(6,Node(1,1)); //这个就是把大小变成6，原本有的不动，扩展出来的用（0,0）填 myvector.resize(10); cout&lt;&lt;&#34;sixth out:&#34;; for(int i=0;i&lt;myvector.size();i&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;&lt;myvector[i].x; } cout&lt;&lt;endl; //最后说一下swap //vector这里的swap和algorithm里面的swap是大不一样的， //这里的swap是交换两个vector容器 vt.swap(myvector);//进行了这步以后，vt就和myvector交换了 cout&lt;&lt;&#34;seventh out:&#34;; for(int i=0;i&lt;myvector.size();i&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;&lt;myvector[i].x; } cout&lt;&lt;endl; //另外还有一种添加元素的方法是insert，但是不常用，这里就不介绍了 //还有一些其他的非常不常用，我就不介绍了。 } /* 输出： first out: 0 1 2 3 4 5 6 7 second out: 4 5 6 7 third out: 100 100 fourth out: 4 3 2 1 0 fifth out:2 2 0 4 is empty? : 0 size: 5 sixth out: 0 1 2 1 1 1 30 30 30 30 seventh out: 100 100 */ 基本上我平时常用的我均已经在代码中提到了，其实vector本身独立使用并不多见，更多的是vector跟其他stl库结合使用，尤其是algorithm库里的泛型算法。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2012-08-10T12:41:30+00:00">
    <meta property="article:modified_time" content="2012-08-10T12:41:30+00:00">
    <meta property="article:tag" content="C&#43;&#43;">

  <meta itemprop="name" content="STL Containers 之 vector">
  <meta itemprop="description" content="我觉得，vector是STL中最常用的容器，没有之一。
因为它简单，安全，也容易理解。实际上它就是一个刚学C&#43;&#43;时我们梦寐以求的动态数组，大小不需要一开始的时候定，而又不像链表操作起来那么麻烦。
先说一下最简单的几个用法吧：
比如说你要创建一个一维数组，数组元素是一个结构体。（为什么用结构体？因为结构体都会了的话，int之类的，就简单了。）
在示例代码中用注释的方式讲解一下各种vector函数的用法。
# include # include using namespace std; struct Node{ int x,y; Node(){x = 30;} Node(int x,int y):x(x),y(y){}//构造函数 }; int main(){ vectormyvector; //定义一个vector数组 for(int i=0;i&lt;9;i&#43;&#43;){ myvector.push_back(Node(i,1&#43;i)); //插入一个元素 } myvector.pop_back();//与之对应的pop_back是从末尾踢掉一个元素 cout&lt;&lt;&#34;first out:&#34;; for(int i=0;i&lt;myvector.size();i&#43;&#43;){ //vector元素的遍历，几乎跟平时数组一样的写法 cout&lt;&lt;&#34; &#34;&lt;&lt;myvector[i].x; //vector元素的输出 } cout&lt;&lt;endl; //说一下迭代器，迭代器可以理解为指针，目的是为了迭代容器中的元素 //迭代器的定义跟我们声明的容器类型是相同的，在这里是 vector::iterator it; it = myvector.begin()&#43;3; //begin()就是开始的位置，加几就是指向了数组中的第几个 myvector.erase(it); //删除数组第一个元素 //erase函数就是起到删除的作用，但是参数是迭代器 //也可以成段删除，给的两个参数都是迭代器，分别是成段删除的开头位置和末尾位置 myvector.erase(myvector.begin(),myvector.begin()&#43;3);//这里的加操作符是迭代器元素个数的加 //删除了这么多，我们重新输出看看 //此处我们用的迭代器的方法遍历vector数组 //值得一提的是，如果在遍历的过程中删除，那么vector元素在删除操作的同时 //会把被删除元素后面的元素往前移动，有删除的那次指针不加 cout&lt;&lt;&#34;second out:&#34;; for(it = myvector.begin();it&lt;myvector.end();it&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;x; } cout&lt;&lt;endl; //一次性全部删除如何操作？ myvector.clear();//对，调用一次clear就可以了。 //重新分配给vector一些值，下面我们用到assign函数，分配内容。 const Node a(100,0); myvector.assign(4,a);//可以直接分配，第一个是次数，第二个参数是数值(元素) //这样以后，myvector中就是4个{100,0} vector vt; //再用迭代器来范围性的赋值，两个参数分别是开始元素和结尾元素 //同时要说明的是，assign函数调用以后，先前的内容会被清除 vt.assign(myvector.begin()&#43;1,myvector.end()-1); cout&lt;&lt;&#34;third out:&#34;; for(it = vt.begin();it&lt;vt.end();it&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;x; } cout&lt;&lt;endl; Node myints[5]; for(int i=0;i&lt;5;i&#43;&#43;) myints[i] = Node(i,i&#43;1); myvector.assign(myints,myints&#43;5);//最后，用数组assign赋值 //反向迭代器，跟迭代器是一样的，就是以数组的末尾为开头，就是定义的方法有所不同 vector::reverse_iterator rit; //相应的，要从末尾开始，我们要用vector中的rbgin()和rend()函数，意思自然是反向开头和反向末尾 //反向迭代器的用法和迭代器其实是一样的，就是为了统一才出现了rbegin,rend; cout&lt;&lt;&#34;fourth out:&#34;; for(rit=myvector.rbegin();rit&lt;myvector.rend();rit&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;x; } cout&lt;&lt;endl; //然后我们说一下用下标定位数组的元素,用at函数和用中括号是一样的效果 cout&lt;&lt;&#34;fifth out:&#34;; cout&lt;&lt;myvector.at(2).x&lt;&lt;&#34; &#34;&lt;&lt;myvector[2].x&lt;&lt;&#34; &#34;; //front函数和back函数是一对，分别指向数组第一个元素和最后一个元素的值 cout&lt;&lt;myvector.front().x&lt;&lt;&#34; &#34;&lt;&lt;myvector.back().x&lt;&lt;endl; cout&lt;&lt;&#34;is empty? : &#34;&lt;&lt;myvector.empty()&lt;&lt;endl;//vector是否为空 cout&lt;&lt;&#34;size: &#34;&lt;&lt;myvector.size()&lt;&lt;endl;//vector中的元素个数 //说到size，就顺便说一下resize，resize函数可以重新改变vector的大小 myvector.resize(3); //这个就把size变成了3，如果原来的大小超过了3，就把超过的地方删去， //如果原来不足3，就自动调用缺省构造函数 myvector.resize(6,Node(1,1)); //这个就是把大小变成6，原本有的不动，扩展出来的用（0,0）填 myvector.resize(10); cout&lt;&lt;&#34;sixth out:&#34;; for(int i=0;i&lt;myvector.size();i&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;&lt;myvector[i].x; } cout&lt;&lt;endl; //最后说一下swap //vector这里的swap和algorithm里面的swap是大不一样的， //这里的swap是交换两个vector容器 vt.swap(myvector);//进行了这步以后，vt就和myvector交换了 cout&lt;&lt;&#34;seventh out:&#34;; for(int i=0;i&lt;myvector.size();i&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;&lt;myvector[i].x; } cout&lt;&lt;endl; //另外还有一种添加元素的方法是insert，但是不常用，这里就不介绍了 //还有一些其他的非常不常用，我就不介绍了。 } /* 输出： first out: 0 1 2 3 4 5 6 7 second out: 4 5 6 7 third out: 100 100 fourth out: 4 3 2 1 0 fifth out:2 2 0 4 is empty? : 0 size: 5 sixth out: 0 1 2 1 1 1 30 30 30 30 seventh out: 100 100 */ 基本上我平时常用的我均已经在代码中提到了，其实vector本身独立使用并不多见，更多的是vector跟其他stl库结合使用，尤其是algorithm库里的泛型算法。">
  <meta itemprop="datePublished" content="2012-08-10T12:41:30+00:00">
  <meta itemprop="dateModified" content="2012-08-10T12:41:30+00:00">
  <meta itemprop="wordCount" content="215">
  <meta itemprop="keywords" content="C&#43;&#43;">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="STL Containers 之 vector">
  <meta name="twitter:description" content="我觉得，vector是STL中最常用的容器，没有之一。
因为它简单，安全，也容易理解。实际上它就是一个刚学C&#43;&#43;时我们梦寐以求的动态数组，大小不需要一开始的时候定，而又不像链表操作起来那么麻烦。
先说一下最简单的几个用法吧：
比如说你要创建一个一维数组，数组元素是一个结构体。（为什么用结构体？因为结构体都会了的话，int之类的，就简单了。）
在示例代码中用注释的方式讲解一下各种vector函数的用法。
# include # include using namespace std; struct Node{ int x,y; Node(){x = 30;} Node(int x,int y):x(x),y(y){}//构造函数 }; int main(){ vectormyvector; //定义一个vector数组 for(int i=0;i&lt;9;i&#43;&#43;){ myvector.push_back(Node(i,1&#43;i)); //插入一个元素 } myvector.pop_back();//与之对应的pop_back是从末尾踢掉一个元素 cout&lt;&lt;&#34;first out:&#34;; for(int i=0;i&lt;myvector.size();i&#43;&#43;){ //vector元素的遍历，几乎跟平时数组一样的写法 cout&lt;&lt;&#34; &#34;&lt;&lt;myvector[i].x; //vector元素的输出 } cout&lt;&lt;endl; //说一下迭代器，迭代器可以理解为指针，目的是为了迭代容器中的元素 //迭代器的定义跟我们声明的容器类型是相同的，在这里是 vector::iterator it; it = myvector.begin()&#43;3; //begin()就是开始的位置，加几就是指向了数组中的第几个 myvector.erase(it); //删除数组第一个元素 //erase函数就是起到删除的作用，但是参数是迭代器 //也可以成段删除，给的两个参数都是迭代器，分别是成段删除的开头位置和末尾位置 myvector.erase(myvector.begin(),myvector.begin()&#43;3);//这里的加操作符是迭代器元素个数的加 //删除了这么多，我们重新输出看看 //此处我们用的迭代器的方法遍历vector数组 //值得一提的是，如果在遍历的过程中删除，那么vector元素在删除操作的同时 //会把被删除元素后面的元素往前移动，有删除的那次指针不加 cout&lt;&lt;&#34;second out:&#34;; for(it = myvector.begin();it&lt;myvector.end();it&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;x; } cout&lt;&lt;endl; //一次性全部删除如何操作？ myvector.clear();//对，调用一次clear就可以了。 //重新分配给vector一些值，下面我们用到assign函数，分配内容。 const Node a(100,0); myvector.assign(4,a);//可以直接分配，第一个是次数，第二个参数是数值(元素) //这样以后，myvector中就是4个{100,0} vector vt; //再用迭代器来范围性的赋值，两个参数分别是开始元素和结尾元素 //同时要说明的是，assign函数调用以后，先前的内容会被清除 vt.assign(myvector.begin()&#43;1,myvector.end()-1); cout&lt;&lt;&#34;third out:&#34;; for(it = vt.begin();it&lt;vt.end();it&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;x; } cout&lt;&lt;endl; Node myints[5]; for(int i=0;i&lt;5;i&#43;&#43;) myints[i] = Node(i,i&#43;1); myvector.assign(myints,myints&#43;5);//最后，用数组assign赋值 //反向迭代器，跟迭代器是一样的，就是以数组的末尾为开头，就是定义的方法有所不同 vector::reverse_iterator rit; //相应的，要从末尾开始，我们要用vector中的rbgin()和rend()函数，意思自然是反向开头和反向末尾 //反向迭代器的用法和迭代器其实是一样的，就是为了统一才出现了rbegin,rend; cout&lt;&lt;&#34;fourth out:&#34;; for(rit=myvector.rbegin();rit&lt;myvector.rend();rit&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;x; } cout&lt;&lt;endl; //然后我们说一下用下标定位数组的元素,用at函数和用中括号是一样的效果 cout&lt;&lt;&#34;fifth out:&#34;; cout&lt;&lt;myvector.at(2).x&lt;&lt;&#34; &#34;&lt;&lt;myvector[2].x&lt;&lt;&#34; &#34;; //front函数和back函数是一对，分别指向数组第一个元素和最后一个元素的值 cout&lt;&lt;myvector.front().x&lt;&lt;&#34; &#34;&lt;&lt;myvector.back().x&lt;&lt;endl; cout&lt;&lt;&#34;is empty? : &#34;&lt;&lt;myvector.empty()&lt;&lt;endl;//vector是否为空 cout&lt;&lt;&#34;size: &#34;&lt;&lt;myvector.size()&lt;&lt;endl;//vector中的元素个数 //说到size，就顺便说一下resize，resize函数可以重新改变vector的大小 myvector.resize(3); //这个就把size变成了3，如果原来的大小超过了3，就把超过的地方删去， //如果原来不足3，就自动调用缺省构造函数 myvector.resize(6,Node(1,1)); //这个就是把大小变成6，原本有的不动，扩展出来的用（0,0）填 myvector.resize(10); cout&lt;&lt;&#34;sixth out:&#34;; for(int i=0;i&lt;myvector.size();i&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;&lt;myvector[i].x; } cout&lt;&lt;endl; //最后说一下swap //vector这里的swap和algorithm里面的swap是大不一样的， //这里的swap是交换两个vector容器 vt.swap(myvector);//进行了这步以后，vt就和myvector交换了 cout&lt;&lt;&#34;seventh out:&#34;; for(int i=0;i&lt;myvector.size();i&#43;&#43;){ cout&lt;&lt;&#34; &#34;&lt;&lt;myvector[i].x; } cout&lt;&lt;endl; //另外还有一种添加元素的方法是insert，但是不常用，这里就不介绍了 //还有一些其他的非常不常用，我就不介绍了。 } /* 输出： first out: 0 1 2 3 4 5 6 7 second out: 4 5 6 7 third out: 100 100 fourth out: 4 3 2 1 0 fifth out:2 2 0 4 is empty? : 0 size: 5 sixth out: 0 1 2 1 1 1 30 30 30 30 seventh out: 100 100 */ 基本上我平时常用的我均已经在代码中提到了，其实vector本身独立使用并不多见，更多的是vector跟其他stl库结合使用，尤其是algorithm库里的泛型算法。">

      
      
    
	
  </head><body class="ma0 avenir production">

    

  <header>
    <div class="bg-near-white">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        奇迹之流WonderfloW
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/about/" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/archives/" title="Archives page">
              Archives
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>
    </div>
  </header>


    <main class="pb7" role="main">
      
<div class="flex-l mt2 mw8 center">
  <article class="center cf pv5 ph3 ph4-ns mw7">
    <header>
      <p class="f6 b helvetica tracked">
        POSTS
      </p>
      <h1 class="f1">
        STL Containers 之 vector
      </h1>
    </header>
    <div class="nested-copy-line-height lh-copy f4 nested-links nested-img mid-gray">
      <p>我觉得，vector是STL中最常用的容器，没有之一。</p>
<p>因为它简单，安全，也容易理解。实际上它就是一个刚学C++时我们梦寐以求的动态数组，大小不需要一开始的时候定，而又不像链表操作起来那么麻烦。</p>
<p>先说一下最简单的几个用法吧：</p>
<p>比如说你要创建一个一维数组，数组元素是一个结构体。（为什么用结构体？因为结构体都会了的话，int之类的，就简单了。）</p>
<p>在示例代码中用注释的方式讲解一下各种vector函数的用法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#57606a"># include 
</span></span></span><span style="display:flex;"><span><span style="color:#57606a"># include 
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">using</span> <span style="color:#cf222e">namespace</span> std<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">struct</span> <span style="color:#1f2328">Node</span><span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">int</span> x<span style="color:#1f2328">,</span>y<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>Node<span style="color:#1f2328">(){</span>x <span style="color:#0550ae">=</span> <span style="color:#0550ae">30</span><span style="color:#1f2328">;}</span>
</span></span><span style="display:flex;"><span>Node<span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> x<span style="color:#1f2328">,</span><span style="color:#cf222e">int</span> y<span style="color:#1f2328">)</span><span style="color:#0550ae">:</span>x<span style="color:#1f2328">(</span>x<span style="color:#1f2328">),</span>y<span style="color:#1f2328">(</span>y<span style="color:#1f2328">){}</span><span style="color:#57606a">//构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#1f2328">};</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">int</span> <span style="color:#6639ba">main</span><span style="color:#1f2328">(){</span>
</span></span><span style="display:flex;"><span>vectormyvector<span style="color:#1f2328">;</span>   <span style="color:#57606a">//定义一个vector数组
</span></span></span><span style="display:flex;"><span><span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> i<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span><span style="color:#0550ae">9</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>myvector<span style="color:#1f2328">.</span>push_back<span style="color:#1f2328">(</span>Node<span style="color:#1f2328">(</span>i<span style="color:#1f2328">,</span><span style="color:#0550ae">1</span><span style="color:#0550ae">+</span>i<span style="color:#1f2328">));</span>    <span style="color:#57606a">//插入一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>myvector<span style="color:#1f2328">.</span>pop_back<span style="color:#1f2328">();</span><span style="color:#57606a">//与之对应的pop_back是从末尾踢掉一个元素
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34;first out:&#34;</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> i<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span>myvector<span style="color:#1f2328">.</span>size<span style="color:#1f2328">();</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span> <span style="color:#57606a">//vector元素的遍历，几乎跟平时数组一样的写法
</span></span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34; &#34;</span><span style="color:#0550ae">&lt;&lt;</span>myvector<span style="color:#1f2328">[</span>i<span style="color:#1f2328">].</span>x<span style="color:#1f2328">;</span>   <span style="color:#57606a">//vector元素的输出
</span></span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span>endl<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#57606a">//说一下迭代器，迭代器可以理解为指针，目的是为了迭代容器中的元素
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//迭代器的定义跟我们声明的容器类型是相同的，在这里是
</span></span></span><span style="display:flex;"><span>vector<span style="color:#0550ae">::</span>iterator it<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>it <span style="color:#0550ae">=</span> myvector<span style="color:#1f2328">.</span>begin<span style="color:#1f2328">()</span><span style="color:#0550ae">+</span><span style="color:#0550ae">3</span><span style="color:#1f2328">;</span>    <span style="color:#57606a">//begin()就是开始的位置，加几就是指向了数组中的第几个
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>myvector<span style="color:#1f2328">.</span>erase<span style="color:#1f2328">(</span>it<span style="color:#1f2328">);</span> <span style="color:#57606a">//删除数组第一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//erase函数就是起到删除的作用，但是参数是迭代器
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//也可以成段删除，给的两个参数都是迭代器，分别是成段删除的开头位置和末尾位置
</span></span></span><span style="display:flex;"><span>myvector<span style="color:#1f2328">.</span>erase<span style="color:#1f2328">(</span>myvector<span style="color:#1f2328">.</span>begin<span style="color:#1f2328">(),</span>myvector<span style="color:#1f2328">.</span>begin<span style="color:#1f2328">()</span><span style="color:#0550ae">+</span><span style="color:#0550ae">3</span><span style="color:#1f2328">);</span><span style="color:#57606a">//这里的加操作符是迭代器元素个数的加
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//删除了这么多，我们重新输出看看
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//此处我们用的迭代器的方法遍历vector数组
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//值得一提的是，如果在遍历的过程中删除，那么vector元素在删除操作的同时
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//会把被删除元素后面的元素往前移动，有删除的那次指针不加
</span></span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34;second out:&#34;</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">for</span><span style="color:#1f2328">(</span>it <span style="color:#0550ae">=</span> myvector<span style="color:#1f2328">.</span>begin<span style="color:#1f2328">();</span>it<span style="color:#0550ae">&lt;</span>myvector<span style="color:#1f2328">.</span>end<span style="color:#1f2328">();</span>it<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34; &#34;</span><span style="color:#0550ae">&lt;</span>x<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span>endl<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#57606a">//一次性全部删除如何操作？
</span></span></span><span style="display:flex;"><span>myvector<span style="color:#1f2328">.</span>clear<span style="color:#1f2328">();</span><span style="color:#57606a">//对，调用一次clear就可以了。
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#57606a">//重新分配给vector一些值，下面我们用到assign函数，分配内容。
</span></span></span><span style="display:flex;"><span><span style="color:#cf222e">const</span> Node a<span style="color:#1f2328">(</span><span style="color:#0550ae">100</span><span style="color:#1f2328">,</span><span style="color:#0550ae">0</span><span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>myvector<span style="color:#1f2328">.</span>assign<span style="color:#1f2328">(</span><span style="color:#0550ae">4</span><span style="color:#1f2328">,</span>a<span style="color:#1f2328">);</span><span style="color:#57606a">//可以直接分配，第一个是次数，第二个参数是数值(元素)
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//这样以后，myvector中就是4个{100,0}
</span></span></span><span style="display:flex;"><span>vector vt<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#57606a">//再用迭代器来范围性的赋值，两个参数分别是开始元素和结尾元素
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//同时要说明的是，assign函数调用以后，先前的内容会被清除
</span></span></span><span style="display:flex;"><span>vt<span style="color:#1f2328">.</span>assign<span style="color:#1f2328">(</span>myvector<span style="color:#1f2328">.</span>begin<span style="color:#1f2328">()</span><span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#1f2328">,</span>myvector<span style="color:#1f2328">.</span>end<span style="color:#1f2328">()</span><span style="color:#0550ae">-</span><span style="color:#0550ae">1</span><span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34;third out:&#34;</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">for</span><span style="color:#1f2328">(</span>it <span style="color:#0550ae">=</span> vt<span style="color:#1f2328">.</span>begin<span style="color:#1f2328">();</span>it<span style="color:#0550ae">&lt;</span>vt<span style="color:#1f2328">.</span>end<span style="color:#1f2328">();</span>it<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34; &#34;</span><span style="color:#0550ae">&lt;</span>x<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span>endl<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>Node myints<span style="color:#1f2328">[</span><span style="color:#0550ae">5</span><span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> i<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span><span style="color:#0550ae">5</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>myints<span style="color:#1f2328">[</span>i<span style="color:#1f2328">]</span> <span style="color:#0550ae">=</span> Node<span style="color:#1f2328">(</span>i<span style="color:#1f2328">,</span>i<span style="color:#0550ae">+</span><span style="color:#0550ae">1</span><span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>myvector<span style="color:#1f2328">.</span>assign<span style="color:#1f2328">(</span>myints<span style="color:#1f2328">,</span>myints<span style="color:#0550ae">+</span><span style="color:#0550ae">5</span><span style="color:#1f2328">);</span><span style="color:#57606a">//最后，用数组assign赋值
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#57606a">//反向迭代器，跟迭代器是一样的，就是以数组的末尾为开头，就是定义的方法有所不同
</span></span></span><span style="display:flex;"><span>vector<span style="color:#0550ae">::</span>reverse_iterator rit<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#57606a">//相应的，要从末尾开始，我们要用vector中的rbgin()和rend()函数，意思自然是反向开头和反向末尾
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//反向迭代器的用法和迭代器其实是一样的，就是为了统一才出现了rbegin,rend;
</span></span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34;fourth out:&#34;</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">for</span><span style="color:#1f2328">(</span>rit<span style="color:#0550ae">=</span>myvector<span style="color:#1f2328">.</span>rbegin<span style="color:#1f2328">();</span>rit<span style="color:#0550ae">&lt;</span>myvector<span style="color:#1f2328">.</span>rend<span style="color:#1f2328">();</span>rit<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34; &#34;</span><span style="color:#0550ae">&lt;</span>x<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span>endl<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#57606a">//然后我们说一下用下标定位数组的元素,用at函数和用中括号是一样的效果
</span></span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34;fifth out:&#34;</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span>myvector<span style="color:#1f2328">.</span>at<span style="color:#1f2328">(</span><span style="color:#0550ae">2</span><span style="color:#1f2328">).</span>x<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34; &#34;</span><span style="color:#0550ae">&lt;&lt;</span>myvector<span style="color:#1f2328">[</span><span style="color:#0550ae">2</span><span style="color:#1f2328">].</span>x<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34; &#34;</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#57606a">//front函数和back函数是一对，分别指向数组第一个元素和最后一个元素的值
</span></span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span>myvector<span style="color:#1f2328">.</span>front<span style="color:#1f2328">().</span>x<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34; &#34;</span><span style="color:#0550ae">&lt;&lt;</span>myvector<span style="color:#1f2328">.</span>back<span style="color:#1f2328">().</span>x<span style="color:#0550ae">&lt;&lt;</span>endl<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34;is empty? : &#34;</span><span style="color:#0550ae">&lt;&lt;</span>myvector<span style="color:#1f2328">.</span>empty<span style="color:#1f2328">()</span><span style="color:#0550ae">&lt;&lt;</span>endl<span style="color:#1f2328">;</span><span style="color:#57606a">//vector是否为空
</span></span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34;size: &#34;</span><span style="color:#0550ae">&lt;&lt;</span>myvector<span style="color:#1f2328">.</span>size<span style="color:#1f2328">()</span><span style="color:#0550ae">&lt;&lt;</span>endl<span style="color:#1f2328">;</span><span style="color:#57606a">//vector中的元素个数
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//说到size，就顺便说一下resize，resize函数可以重新改变vector的大小
</span></span></span><span style="display:flex;"><span>myvector<span style="color:#1f2328">.</span>resize<span style="color:#1f2328">(</span><span style="color:#0550ae">3</span><span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span><span style="color:#57606a">//这个就把size变成了3，如果原来的大小超过了3，就把超过的地方删去，
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//如果原来不足3，就自动调用缺省构造函数
</span></span></span><span style="display:flex;"><span>myvector<span style="color:#1f2328">.</span>resize<span style="color:#1f2328">(</span><span style="color:#0550ae">6</span><span style="color:#1f2328">,</span>Node<span style="color:#1f2328">(</span><span style="color:#0550ae">1</span><span style="color:#1f2328">,</span><span style="color:#0550ae">1</span><span style="color:#1f2328">));</span>
</span></span><span style="display:flex;"><span><span style="color:#57606a">//这个就是把大小变成6，原本有的不动，扩展出来的用（0,0）填
</span></span></span><span style="display:flex;"><span>myvector<span style="color:#1f2328">.</span>resize<span style="color:#1f2328">(</span><span style="color:#0550ae">10</span><span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34;sixth out:&#34;</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> i<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span>myvector<span style="color:#1f2328">.</span>size<span style="color:#1f2328">();</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34; &#34;</span><span style="color:#0550ae">&lt;&lt;</span>myvector<span style="color:#1f2328">[</span>i<span style="color:#1f2328">].</span>x<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span>endl<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#57606a">//最后说一下swap
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//vector这里的swap和algorithm里面的swap是大不一样的，
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//这里的swap是交换两个vector容器
</span></span></span><span style="display:flex;"><span>vt<span style="color:#1f2328">.</span>swap<span style="color:#1f2328">(</span>myvector<span style="color:#1f2328">);</span><span style="color:#57606a">//进行了这步以后，vt就和myvector交换了
</span></span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34;seventh out:&#34;</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">for</span><span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> i<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span>myvector<span style="color:#1f2328">.</span>size<span style="color:#1f2328">();</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">){</span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span><span style="color:#0a3069">&#34; &#34;</span><span style="color:#0550ae">&lt;&lt;</span>myvector<span style="color:#1f2328">[</span>i<span style="color:#1f2328">].</span>x<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>cout<span style="color:#0550ae">&lt;&lt;</span>endl<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#57606a">//另外还有一种添加元素的方法是insert，但是不常用，这里就不介绍了
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">//还有一些其他的非常不常用，我就不介绍了。
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span><span style="color:#57606a">/*
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">输出：
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">first out: 0 1 2 3 4 5 6 7
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">second out: 4 5 6 7
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">third out: 100 100
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">fourth out: 4 3 2 1 0
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">fifth out:2 2 0 4
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">is empty? : 0
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">size: 5
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">sixth out: 0 1 2 1 1 1 30 30 30 30
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">seventh out: 100 100
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">*/</span>
</span></span></code></pre></div><p>基本上我平时常用的我均已经在代码中提到了，其实vector本身独立使用并不多见，更多的是vector跟其他stl库结合使用，尤其是algorithm库里的泛型算法。</p>
<p>深入阅读：<a href="http://www.cplusplus.com/reference/stl/vector/">C++官方网站上的描述</a></p>

    </div>
  </article>
</div>

    </main>
    <footer class="bg-near-white bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
    <a class="f4 fw4 hover-black no-underline mid-gray dn dib-ns pv2 ph3" href="https://wonderflow.info/">
      &copy;  奇迹之流WonderfloW 2025 
    </a>
    <div><div class="ananke-socials"></div>
</div>
    <a href="https://beian.miit.gov.cn/" class="link db f6 pa2 br3 bg-mid-gray white dim w4 tc"> 沪ICP备2020029591号 </a>
    
  </div>
</footer>


<div class="reading-progress" id="reading-progress"></div>


<button class="back-to-top" id="back-to-top" aria-label="Back to top">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <polyline points="18 15 12 9 6 15"></polyline>
  </svg>
</button>


<script>
(function() {
  
  const progressBar = document.getElementById('reading-progress');
  const backToTop = document.getElementById('back-to-top');

  function updateProgress() {
    const scrollTop = window.scrollY;
    const docHeight = document.documentElement.scrollHeight - window.innerHeight;
    const progress = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;

    if (progressBar) {
      progressBar.style.width = progress + '%';
    }

    
    if (backToTop) {
      if (scrollTop > 300) {
        backToTop.classList.add('visible');
      } else {
        backToTop.classList.remove('visible');
      }
    }
  }

  
  let ticking = false;
  window.addEventListener('scroll', function() {
    if (!ticking) {
      window.requestAnimationFrame(function() {
        updateProgress();
        ticking = false;
      });
      ticking = true;
    }
  });

  
  if (backToTop) {
    backToTop.addEventListener('click', function() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });
  }

  
  updateProgress();
})();
</script>

  </body>
</html>
