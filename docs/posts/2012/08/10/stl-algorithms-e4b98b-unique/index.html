<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>STL Algorithms 之 unique | 奇迹之流WonderfloW</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="C&#43;&#43;的文档中说，STL中的unique是类似于这样实现的：
template &lt;class ForwardIterator&gt;
  ForwardIterator unique ( ForwardIterator first, ForwardIterator last )
{
  ForwardIterator result=first;
  while (&#43;&#43;first != last)
  {
    if (!(*result == *first))  // or: if (!pred(*result,*first)) for the pred version
      *(&#43;&#43;result)=*first;
  }
  return &#43;&#43;result;
}
仔细一看就知道，它并不是帮你直接把一个数组中所有重复的元素除去，而是对数组扫描一次，只看当前元素和前面一个元素，如果当前值和前面的值相等，那么跳过，否则就把这个值算上，迭代器递增，最后返回给你一个位置，表示我扫描到多少个当前值与其前面一个元素值不同的元素。
所以，要真正利用好unique，我们必须先对我们所需要进行unique操作的数组排序，然后再使用unique。
这样以后其实还是不满足我们的要求的，因为实际上unique函数实现的只是把不同的元素“unique”放到数组的前面，而数组的后面还有一段重复的没有去掉。这个时候就可以利用到unique函数的返回值啦，它返回的就是重复元素出现的第一个位置。
另外，unique函数可以接受两个参数（数组的开头，数组的末尾），也可以接受三个参数（数组的开头，数组的末尾，两个元素的比较（即定义怎样算元素相等））
看一下实例吧：
// resizing vector
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

bool myfunction (int i, int j) {
  return (i==j);
}

int main () {
  int myints[] = {10,20,20,20,30,30,20,20,10};    // 10 20 20 20 30 30 20 20 10
  vector&lt;int&gt; myvector (myints,myints&#43;9);
  vector&lt;int&gt;::iterator it;

  
  it = unique (myvector.begin(), myvector.end()); // 10 20 30 20 10 ?  ?  ?  ?
  //尖所指即it的位置                                //                ^            
												  
  myvector.erase( it , myvector.end() );       // 第一种去掉末尾的方法

  cout &lt;&lt; &#34;first: myvector contains:&#34;;
  for (int i=0;i&lt;myvector.size();i&#43;&#43;)
    cout &lt;&lt; &#34; &#34; &lt;&lt; myvector[i];
  cout&lt;&lt;endl;

  sort(myvector.begin(),myvector.end());		//先排序

  it = unique (myvector.begin(), myvector.end(), myfunction);   
  // 使用比较函数，但此处是跟缺省的比较一样的。

  myvector.resize( it - myvector.begin() );       // 10 20 30 

  cout &lt;&lt; &#34;second: myvector contains:&#34;;
  for (it=myvector.begin(); it!=myvector.end(); &#43;&#43;it)
    cout &lt;&lt; &#34; &#34; &lt;&lt; *it;
  cout &lt;&lt; endl;

  return 0;
}

/*
输出：
first: myvector contains: 10 20 30 20 10
second: myvector contains: 10 20 30
*/
深入阅读：C&#43;&#43;官方网站上的描述。">
    <meta name="generator" content="Hugo 0.153.4">
    
    
    
      <meta name="robots" content="index, follow">
    
    <meta name="author" content="admin">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.efe4d852f731d5d1fbb87718387202a97aafd768cdcdaed0662bbe6982e91824.css" >



  
    <link rel="stylesheet" href="/css/custom.css">
  


    


    
      
<link rel="shortcut icon" href="/favicon_io/favicon.ico" type="image/x-icon" />


    

    

    
      <link rel="canonical" href="https://wonderflow.info/posts/2012/08/10/stl-algorithms-e4b98b-unique/">
    

    
    
    <meta property="og:url" content="https://wonderflow.info/posts/2012/08/10/stl-algorithms-e4b98b-unique/">
  <meta property="og:site_name" content="奇迹之流WonderfloW">
  <meta property="og:title" content="STL Algorithms 之 unique">
  <meta property="og:description" content="C&#43;&#43;的文档中说，STL中的unique是类似于这样实现的：
template &lt;class ForwardIterator&gt; ForwardIterator unique ( ForwardIterator first, ForwardIterator last ) { ForwardIterator result=first; while (&#43;&#43;first != last) { if (!(*result == *first)) // or: if (!pred(*result,*first)) for the pred version *(&#43;&#43;result)=*first; } return &#43;&#43;result; } 仔细一看就知道，它并不是帮你直接把一个数组中所有重复的元素除去，而是对数组扫描一次，只看当前元素和前面一个元素，如果当前值和前面的值相等，那么跳过，否则就把这个值算上，迭代器递增，最后返回给你一个位置，表示我扫描到多少个当前值与其前面一个元素值不同的元素。
所以，要真正利用好unique，我们必须先对我们所需要进行unique操作的数组排序，然后再使用unique。
这样以后其实还是不满足我们的要求的，因为实际上unique函数实现的只是把不同的元素“unique”放到数组的前面，而数组的后面还有一段重复的没有去掉。这个时候就可以利用到unique函数的返回值啦，它返回的就是重复元素出现的第一个位置。
另外，unique函数可以接受两个参数（数组的开头，数组的末尾），也可以接受三个参数（数组的开头，数组的末尾，两个元素的比较（即定义怎样算元素相等））
看一下实例吧：
// resizing vector #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; bool myfunction (int i, int j) { return (i==j); } int main () { int myints[] = {10,20,20,20,30,30,20,20,10}; // 10 20 20 20 30 30 20 20 10 vector&lt;int&gt; myvector (myints,myints&#43;9); vector&lt;int&gt;::iterator it; it = unique (myvector.begin(), myvector.end()); // 10 20 30 20 10 ? ? ? ? //尖所指即it的位置 // ^ myvector.erase( it , myvector.end() ); // 第一种去掉末尾的方法 cout &lt;&lt; &#34;first: myvector contains:&#34;; for (int i=0;i&lt;myvector.size();i&#43;&#43;) cout &lt;&lt; &#34; &#34; &lt;&lt; myvector[i]; cout&lt;&lt;endl; sort(myvector.begin(),myvector.end());	//先排序 it = unique (myvector.begin(), myvector.end(), myfunction); // 使用比较函数，但此处是跟缺省的比较一样的。 myvector.resize( it - myvector.begin() ); // 10 20 30 cout &lt;&lt; &#34;second: myvector contains:&#34;; for (it=myvector.begin(); it!=myvector.end(); &#43;&#43;it) cout &lt;&lt; &#34; &#34; &lt;&lt; *it; cout &lt;&lt; endl; return 0; } /* 输出： first: myvector contains: 10 20 30 20 10 second: myvector contains: 10 20 30 */ 深入阅读：C&#43;&#43;官方网站上的描述。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2012-08-10T10:40:13+00:00">
    <meta property="article:modified_time" content="2012-08-10T10:40:13+00:00">
    <meta property="article:tag" content="C&#43;&#43;">

  <meta itemprop="name" content="STL Algorithms 之 unique">
  <meta itemprop="description" content="C&#43;&#43;的文档中说，STL中的unique是类似于这样实现的：
template &lt;class ForwardIterator&gt; ForwardIterator unique ( ForwardIterator first, ForwardIterator last ) { ForwardIterator result=first; while (&#43;&#43;first != last) { if (!(*result == *first)) // or: if (!pred(*result,*first)) for the pred version *(&#43;&#43;result)=*first; } return &#43;&#43;result; } 仔细一看就知道，它并不是帮你直接把一个数组中所有重复的元素除去，而是对数组扫描一次，只看当前元素和前面一个元素，如果当前值和前面的值相等，那么跳过，否则就把这个值算上，迭代器递增，最后返回给你一个位置，表示我扫描到多少个当前值与其前面一个元素值不同的元素。
所以，要真正利用好unique，我们必须先对我们所需要进行unique操作的数组排序，然后再使用unique。
这样以后其实还是不满足我们的要求的，因为实际上unique函数实现的只是把不同的元素“unique”放到数组的前面，而数组的后面还有一段重复的没有去掉。这个时候就可以利用到unique函数的返回值啦，它返回的就是重复元素出现的第一个位置。
另外，unique函数可以接受两个参数（数组的开头，数组的末尾），也可以接受三个参数（数组的开头，数组的末尾，两个元素的比较（即定义怎样算元素相等））
看一下实例吧：
// resizing vector #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; bool myfunction (int i, int j) { return (i==j); } int main () { int myints[] = {10,20,20,20,30,30,20,20,10}; // 10 20 20 20 30 30 20 20 10 vector&lt;int&gt; myvector (myints,myints&#43;9); vector&lt;int&gt;::iterator it; it = unique (myvector.begin(), myvector.end()); // 10 20 30 20 10 ? ? ? ? //尖所指即it的位置 // ^ myvector.erase( it , myvector.end() ); // 第一种去掉末尾的方法 cout &lt;&lt; &#34;first: myvector contains:&#34;; for (int i=0;i&lt;myvector.size();i&#43;&#43;) cout &lt;&lt; &#34; &#34; &lt;&lt; myvector[i]; cout&lt;&lt;endl; sort(myvector.begin(),myvector.end());	//先排序 it = unique (myvector.begin(), myvector.end(), myfunction); // 使用比较函数，但此处是跟缺省的比较一样的。 myvector.resize( it - myvector.begin() ); // 10 20 30 cout &lt;&lt; &#34;second: myvector contains:&#34;; for (it=myvector.begin(); it!=myvector.end(); &#43;&#43;it) cout &lt;&lt; &#34; &#34; &lt;&lt; *it; cout &lt;&lt; endl; return 0; } /* 输出： first: myvector contains: 10 20 30 20 10 second: myvector contains: 10 20 30 */ 深入阅读：C&#43;&#43;官方网站上的描述。">
  <meta itemprop="datePublished" content="2012-08-10T10:40:13+00:00">
  <meta itemprop="dateModified" content="2012-08-10T10:40:13+00:00">
  <meta itemprop="wordCount" content="185">
  <meta itemprop="keywords" content="C&#43;&#43;">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="STL Algorithms 之 unique">
  <meta name="twitter:description" content="C&#43;&#43;的文档中说，STL中的unique是类似于这样实现的：
template &lt;class ForwardIterator&gt; ForwardIterator unique ( ForwardIterator first, ForwardIterator last ) { ForwardIterator result=first; while (&#43;&#43;first != last) { if (!(*result == *first)) // or: if (!pred(*result,*first)) for the pred version *(&#43;&#43;result)=*first; } return &#43;&#43;result; } 仔细一看就知道，它并不是帮你直接把一个数组中所有重复的元素除去，而是对数组扫描一次，只看当前元素和前面一个元素，如果当前值和前面的值相等，那么跳过，否则就把这个值算上，迭代器递增，最后返回给你一个位置，表示我扫描到多少个当前值与其前面一个元素值不同的元素。
所以，要真正利用好unique，我们必须先对我们所需要进行unique操作的数组排序，然后再使用unique。
这样以后其实还是不满足我们的要求的，因为实际上unique函数实现的只是把不同的元素“unique”放到数组的前面，而数组的后面还有一段重复的没有去掉。这个时候就可以利用到unique函数的返回值啦，它返回的就是重复元素出现的第一个位置。
另外，unique函数可以接受两个参数（数组的开头，数组的末尾），也可以接受三个参数（数组的开头，数组的末尾，两个元素的比较（即定义怎样算元素相等））
看一下实例吧：
// resizing vector #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; bool myfunction (int i, int j) { return (i==j); } int main () { int myints[] = {10,20,20,20,30,30,20,20,10}; // 10 20 20 20 30 30 20 20 10 vector&lt;int&gt; myvector (myints,myints&#43;9); vector&lt;int&gt;::iterator it; it = unique (myvector.begin(), myvector.end()); // 10 20 30 20 10 ? ? ? ? //尖所指即it的位置 // ^ myvector.erase( it , myvector.end() ); // 第一种去掉末尾的方法 cout &lt;&lt; &#34;first: myvector contains:&#34;; for (int i=0;i&lt;myvector.size();i&#43;&#43;) cout &lt;&lt; &#34; &#34; &lt;&lt; myvector[i]; cout&lt;&lt;endl; sort(myvector.begin(),myvector.end());	//先排序 it = unique (myvector.begin(), myvector.end(), myfunction); // 使用比较函数，但此处是跟缺省的比较一样的。 myvector.resize( it - myvector.begin() ); // 10 20 30 cout &lt;&lt; &#34;second: myvector contains:&#34;; for (it=myvector.begin(); it!=myvector.end(); &#43;&#43;it) cout &lt;&lt; &#34; &#34; &lt;&lt; *it; cout &lt;&lt; endl; return 0; } /* 输出： first: myvector contains: 10 20 30 20 10 second: myvector contains: 10 20 30 */ 深入阅读：C&#43;&#43;官方网站上的描述。">

      
      
    
	
  </head><body class="ma0 avenir production">

    

  <header>
    <div class="bg-near-white">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        奇迹之流WonderfloW
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/about/" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/archives/" title="Archives page">
              Archives
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>
    </div>
  </header>


    <main class="pb7" role="main">
      
<div class="flex-l mt2 mw8 center">
  <article class="center cf pv5 ph3 ph4-ns mw7">
    <header>
      <p class="f6 b helvetica tracked">
        POSTS
      </p>
      <h1 class="f1">
        STL Algorithms 之 unique
      </h1>
    </header>
    <div class="nested-copy-line-height lh-copy f4 nested-links nested-img mid-gray">
      <p>C++的文档中说，STL中的unique是类似于这样实现的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>template &lt;class ForwardIterator&gt;
</span></span><span style="display:flex;"><span>  ForwardIterator unique ( ForwardIterator first, ForwardIterator last )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ForwardIterator result=first;
</span></span><span style="display:flex;"><span>  while (++first != last)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    if (!(*result == *first))  // or: if (!pred(*result,*first)) for the pred version
</span></span><span style="display:flex;"><span>      *(++result)=*first;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  return ++result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>仔细一看就知道，它并不是帮你直接把一个数组中所有重复的元素除去，而是对数组扫描一次，只看当前元素和前面一个元素，如果当前值和前面的值相等，那么跳过，否则就把这个值算上，迭代器递增，最后返回给你一个位置，表示我扫描到多少个当前值与其前面一个元素值不同的元素。</p>
<p>所以，要真正利用好unique，我们必须先对我们所需要进行unique操作的数组排序，然后再使用unique。</p>
<p>这样以后其实还是不满足我们的要求的，因为实际上unique函数实现的只是把不同的元素“unique”放到数组的前面，而数组的后面还有一段重复的没有去掉。这个时候就可以利用到unique函数的返回值啦，它返回的就是重复元素出现的第一个位置。</p>
<p>另外，unique函数可以接受两个参数（数组的开头，数组的末尾），也可以接受三个参数（数组的开头，数组的末尾，两个元素的比较（即定义怎样算元素相等））</p>
<p>看一下实例吧：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#57606a">// resizing vector
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">#include</span> <span style="color:#57606a">&lt;iostream&gt;</span><span style="color:#57606a">
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">#include</span> <span style="color:#57606a">&lt;vector&gt;</span><span style="color:#57606a">
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">#include</span> <span style="color:#57606a">&lt;algorithm&gt;</span><span style="color:#57606a">
</span></span></span><span style="display:flex;"><span><span style="color:#cf222e">using</span> <span style="color:#cf222e">namespace</span> std<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">bool</span> <span style="color:#6639ba">myfunction</span> <span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> i<span style="color:#1f2328">,</span> <span style="color:#cf222e">int</span> j<span style="color:#1f2328">)</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#cf222e">return</span> <span style="color:#1f2328">(</span>i<span style="color:#0550ae">==</span>j<span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">int</span> <span style="color:#6639ba">main</span> <span style="color:#1f2328">()</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#cf222e">int</span> myints<span style="color:#1f2328">[]</span> <span style="color:#0550ae">=</span> <span style="color:#1f2328">{</span><span style="color:#0550ae">10</span><span style="color:#1f2328">,</span><span style="color:#0550ae">20</span><span style="color:#1f2328">,</span><span style="color:#0550ae">20</span><span style="color:#1f2328">,</span><span style="color:#0550ae">20</span><span style="color:#1f2328">,</span><span style="color:#0550ae">30</span><span style="color:#1f2328">,</span><span style="color:#0550ae">30</span><span style="color:#1f2328">,</span><span style="color:#0550ae">20</span><span style="color:#1f2328">,</span><span style="color:#0550ae">20</span><span style="color:#1f2328">,</span><span style="color:#0550ae">10</span><span style="color:#1f2328">};</span>    <span style="color:#57606a">// 10 20 20 20 30 30 20 20 10
</span></span></span><span style="display:flex;"><span>  vector<span style="color:#0550ae">&lt;</span><span style="color:#cf222e">int</span><span style="color:#0550ae">&gt;</span> myvector <span style="color:#1f2328">(</span>myints<span style="color:#1f2328">,</span>myints<span style="color:#0550ae">+</span><span style="color:#0550ae">9</span><span style="color:#1f2328">);</span>
</span></span><span style="display:flex;"><span>  vector<span style="color:#0550ae">&lt;</span><span style="color:#cf222e">int</span><span style="color:#0550ae">&gt;::</span>iterator it<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  it <span style="color:#0550ae">=</span> unique <span style="color:#1f2328">(</span>myvector<span style="color:#1f2328">.</span>begin<span style="color:#1f2328">(),</span> myvector<span style="color:#1f2328">.</span>end<span style="color:#1f2328">());</span> <span style="color:#57606a">// 10 20 30 20 10 ?  ?  ?  ?
</span></span></span><span style="display:flex;"><span>  <span style="color:#57606a">//尖所指即it的位置                                //                ^            
</span></span></span><span style="display:flex;"><span>												  
</span></span><span style="display:flex;"><span>  myvector<span style="color:#1f2328">.</span>erase<span style="color:#1f2328">(</span> it <span style="color:#1f2328">,</span> myvector<span style="color:#1f2328">.</span>end<span style="color:#1f2328">()</span> <span style="color:#1f2328">);</span>       <span style="color:#57606a">// 第一种去掉末尾的方法
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  cout <span style="color:#0550ae">&lt;&lt;</span> <span style="color:#0a3069">&#34;first: myvector contains:&#34;</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#cf222e">for</span> <span style="color:#1f2328">(</span><span style="color:#cf222e">int</span> i<span style="color:#0550ae">=</span><span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>i<span style="color:#0550ae">&lt;</span>myvector<span style="color:#1f2328">.</span>size<span style="color:#1f2328">();</span>i<span style="color:#0550ae">++</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>    cout <span style="color:#0550ae">&lt;&lt;</span> <span style="color:#0a3069">&#34; &#34;</span> <span style="color:#0550ae">&lt;&lt;</span> myvector<span style="color:#1f2328">[</span>i<span style="color:#1f2328">];</span>
</span></span><span style="display:flex;"><span>  cout<span style="color:#0550ae">&lt;&lt;</span>endl<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  sort<span style="color:#1f2328">(</span>myvector<span style="color:#1f2328">.</span>begin<span style="color:#1f2328">(),</span>myvector<span style="color:#1f2328">.</span>end<span style="color:#1f2328">());</span>		<span style="color:#57606a">//先排序
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  it <span style="color:#0550ae">=</span> unique <span style="color:#1f2328">(</span>myvector<span style="color:#1f2328">.</span>begin<span style="color:#1f2328">(),</span> myvector<span style="color:#1f2328">.</span>end<span style="color:#1f2328">(),</span> myfunction<span style="color:#1f2328">);</span>   
</span></span><span style="display:flex;"><span>  <span style="color:#57606a">// 使用比较函数，但此处是跟缺省的比较一样的。
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  myvector<span style="color:#1f2328">.</span>resize<span style="color:#1f2328">(</span> it <span style="color:#0550ae">-</span> myvector<span style="color:#1f2328">.</span>begin<span style="color:#1f2328">()</span> <span style="color:#1f2328">);</span>       <span style="color:#57606a">// 10 20 30 
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  cout <span style="color:#0550ae">&lt;&lt;</span> <span style="color:#0a3069">&#34;second: myvector contains:&#34;</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#cf222e">for</span> <span style="color:#1f2328">(</span>it<span style="color:#0550ae">=</span>myvector<span style="color:#1f2328">.</span>begin<span style="color:#1f2328">();</span> it<span style="color:#0550ae">!=</span>myvector<span style="color:#1f2328">.</span>end<span style="color:#1f2328">();</span> <span style="color:#0550ae">++</span>it<span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>    cout <span style="color:#0550ae">&lt;&lt;</span> <span style="color:#0a3069">&#34; &#34;</span> <span style="color:#0550ae">&lt;&lt;</span> <span style="color:#0550ae">*</span>it<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>  cout <span style="color:#0550ae">&lt;&lt;</span> endl<span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#cf222e">return</span> <span style="color:#0550ae">0</span><span style="color:#1f2328">;</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#57606a">/*
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">输出：
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">first: myvector contains: 10 20 30 20 10
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">second: myvector contains: 10 20 30
</span></span></span><span style="display:flex;"><span><span style="color:#57606a">*/</span>
</span></span></code></pre></div><p>深入阅读：<a href="http://www.cplusplus.com/reference/algorithm/unique/">C++官方网站上的描述</a>。</p>

    </div>
  </article>
</div>

    </main>
    <footer class="bg-near-white bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
    <a class="f4 fw4 hover-black no-underline mid-gray dn dib-ns pv2 ph3" href="https://wonderflow.info/">
      &copy;  奇迹之流WonderfloW 2025 
    </a>
    <div><div class="ananke-socials"></div>
</div>
    <a href="https://beian.miit.gov.cn/" class="link db f6 pa2 br3 bg-mid-gray white dim w4 tc"> 沪ICP备2020029591号 </a>
    
  </div>
</footer>


<div class="reading-progress" id="reading-progress"></div>


<button class="back-to-top" id="back-to-top" aria-label="Back to top">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <polyline points="18 15 12 9 6 15"></polyline>
  </svg>
</button>


<script>
(function() {
  
  const progressBar = document.getElementById('reading-progress');
  const backToTop = document.getElementById('back-to-top');

  function updateProgress() {
    const scrollTop = window.scrollY;
    const docHeight = document.documentElement.scrollHeight - window.innerHeight;
    const progress = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;

    if (progressBar) {
      progressBar.style.width = progress + '%';
    }

    
    if (backToTop) {
      if (scrollTop > 300) {
        backToTop.classList.add('visible');
      } else {
        backToTop.classList.remove('visible');
      }
    }
  }

  
  let ticking = false;
  window.addEventListener('scroll', function() {
    if (!ticking) {
      window.requestAnimationFrame(function() {
        updateProgress();
        ticking = false;
      });
      ticking = true;
    }
  });

  
  if (backToTop) {
    backToTop.addEventListener('click', function() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });
  }

  
  updateProgress();
})();
</script>

  </body>
</html>
