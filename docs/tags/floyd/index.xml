<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Floyd on 奇迹之流WonderfloW</title>
    <link>https://wonderflow.info/tags/floyd/</link>
    <description>Recent content in Floyd on 奇迹之流WonderfloW</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 02 Aug 2012 14:42:06 +0000</lastBuildDate>
    <atom:link href="https://wonderflow.info/tags/floyd/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>扯 &amp;&amp; 最短路floyd的DP解法解释</title>
      <link>https://wonderflow.info/posts/2012/08/02/e689af-e69c80e79fade8b7affloyde79a84dpe8a7a3e6b395e8a7a3e9878a/</link>
      <pubDate>Thu, 02 Aug 2012 14:42:06 +0000</pubDate>
      <guid>https://wonderflow.info/posts/2012/08/02/e689af-e69c80e79fade8b7affloyde79a84dpe8a7a3e6b395e8a7a3e9878a/</guid>
      <description>&lt;p&gt;帮鱼头整理集训队训练教程，据说要出书，瞬间感到压力巨大。就那些平时大家随便写写，只是给自己看看的，非常散漫的解题报告，和专题上很多算法本质都不理解的各种报告组成的一个文档。我真的，压力巨大。那么尽自己力量去整理吧。&lt;/p&gt;&#xA;&lt;p&gt;整本书的结构就是：&#xA;章节（专题介绍-&amp;gt;讲的参差不齐）；子目录（该专题算法介绍-&amp;gt;伪代码(反正不是通俗易懂)）;&#xA;子目录：例题-&amp;gt;题意-&amp;gt;思路-&amp;gt;代码（这就导致小半本书代码）。&lt;/p&gt;&#xA;&lt;p&gt;我也不知道这样是好是坏，是否适合读者入门。反正我最讨厌大段大段贴代码的书了。&lt;/p&gt;&#xA;&lt;p&gt;然后尽力整理吧，其实这本书倒更像是一个模板库，对于把所有专题都了解过的人，是一本很好的复习资料。我就花了一个晚上好好的把整个图论复习了一把。学到不少啊。然后在复习的过程中纠正了书本的各种错误！然后想想，我整理两章都这么折磨了，鱼头可是要出一整本书啊，真是，蛋疼了。&lt;/p&gt;&#xA;&lt;p&gt;之前鱼头请客带我们一起去游泳，跟鱼头在地铁上聊到我们judge有很多产品，上线了以后出现了一不小心就不能用，然后三天两头出bug的情况。然后鱼头说要来一个测试审核机制，审核通过了才能上线。当时我就说，哪里等的及啊，我们每一个应用完成，都是迫在眉睫需要的时候急急忙忙上线的，而本身我们做judge也不存在竞争关系，大家都是做不同的功能，做好了就能上线的。归根结底还是人手不够，需求太多，耐心不够，时间不够。（PS：做的好没奖金，做的不好也没什么惩罚~o(∩_∩)o ~）这样的情况就导致了每每都是到了deadline我们的任务才完成，也来不及缓冲。&lt;/p&gt;&#xA;&lt;p&gt;然后我觉得，出书这个事情，其实跟产品上线这个事情是一样的。现在就前期朱艺楠一个人搞搞，后期鱼头一个人搞搞，我跟ZYZ瞎参合一下。还这么急。肯定后面又是一堆bug。&lt;/p&gt;&#xA;&lt;p&gt;要我来安排的话，就应该把校验书本这个任务安排给每一个想要参加regional比赛的队伍，因为校验书本本身也是一个整理模板的过程啊（针对这本书的特殊性，就是一个模板介绍。）然后每个队各尽所能编排自己队的模板（整理算法教程）。最后把书本的好坏也加入到是否能获得regional比赛资格的一个要素。然后大家精心整理的书再一合并，把每个队的优势专题截取下来，效果一定不会差！&lt;/p&gt;&#xA;&lt;p&gt;（当然，这前半部分都是我的个人扯淡。具体说不定还存在很多很多我没考虑过的问题。不过我要强调的是：跟鱼头一起去游泳真开心，哈哈~）&lt;/p&gt;&#xA;&lt;p&gt;然后在校验算法教程的时候，发现了很久以前碰到的一个问题：floyd求最短路，为什么就是那么DP的，为什么？思考了很久，在网上找到了答案~&lt;/p&gt;&#xA;&lt;p&gt;floyd算法是求解ASPS(all paris shortest paths)的一种算法，时间复杂度是O(n^3). 边权可正可负。复杂度O(V^3)，求出任何一个点到其他点的最短路径。&lt;/p&gt;&#xA;&lt;p&gt;floyd也是一种典型的动态规划算法。其动态规划方程是：&lt;/p&gt;&#xA;&lt;p&gt;{% codeblock %}&lt;/p&gt;&#xA;&lt;p&gt;dp[i][j][k] = min( dp[i][k][k-1]+dp[k][j][k-1]);&lt;/p&gt;&#xA;&lt;p&gt;{% endcodeblock %}&lt;/p&gt;&#xA;&lt;p&gt;很明显，对于一个N个节点的网络，可以设置状态数组为 dp[N][N][N]&#xA;然后根据状态转移的方程，得出代码如下：&lt;/p&gt;&#xA;&lt;p&gt;{% codeblock %}&lt;/p&gt;&#xA;&lt;p&gt;for(int i=1;i&amp;lt;=N;i++)&#xA;for(int j=1;j&amp;lt;=N;j++)&#xA;dp[i][j][0] = 0;&#xA;for(int k=1;k&amp;lt;=N;k++){&#xA;for(int i=1;i&amp;lt;=N;i++){&#xA;for(int j=1;j&amp;lt;=N;j++){&#xA;dp[i][j][k] = min(dp[i][j][k-1], dp[i][k][k-1]+dp[k][j][k-1]);&#xA;}}}&lt;/p&gt;&#xA;&lt;p&gt;{% endcodeblock %}&lt;/p&gt;&#xA;&lt;p&gt;这个状态除了可以用三维的表示外，还可以用二维（或者滚动数组）表示。因为每个k只和k-1有关。&lt;/p&gt;&#xA;&lt;p&gt;{% codeblock %}&lt;/p&gt;&#xA;&lt;p&gt;for(int i=1;i&amp;lt;=N;i++)&#xA;for(int j=1;j&amp;lt;=N;j++)&#xA;dp[i][j] = 0;&#xA;for(int k=1;k&amp;lt;=N;k++){&#xA;for(int i=1;i&amp;lt;=N;i++){&#xA;for(int j=1;j&amp;lt;=N;j++){&#xA;dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);&#xA;}}}&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
